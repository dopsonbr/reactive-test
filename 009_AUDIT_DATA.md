# 009 Audit Data Service - Event Tracking and Storage

## Overview

This plan introduces an audit-service for capturing, storing, and querying audit events from cart-service and other services. The service provides both a CRUD REST API for direct event submission and a message queue consumer as the primary ingestion mechanism. Audit data is stored in an append-only wide-column database optimized for time-series queries.

**Related Plans:**
- **008_CART_SERVICE** - Cart service will publish audit events (can be developed in parallel)

## Goals

1. Create a new audit-service application
2. Implement message queue consumer for audit event ingestion (primary mechanism)
3. Implement CRUD REST API for audit events (secondary/convenience mechanism)
4. Store audit data in append-only wide-column database
5. Provide query APIs for audit trail retrieval
6. Apply resilience, logging, and security patterns
7. Create shared platform library for audit event publishing

## Architecture

### High-Level Flow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  cart-service   │     │ product-service │     │ other-services  │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                       │
         │ publish               │ publish               │ publish
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Message Queue (Redis Streams)               │
│                         audit-events stream                      │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
                                  │ consume
                                  ▼
                    ┌─────────────────────────┐
                    │     audit-service       │
                    │  ┌──────────────────┐   │
                    │  │ Queue Consumer   │   │    ┌──────────────┐
                    │  └────────┬─────────┘   │    │  REST API    │
                    │           │             │◄───│ (secondary)  │
                    │           ▼             │    └──────────────┘
                    │  ┌──────────────────┐   │
                    │  │ Audit Repository │   │
                    │  └────────┬─────────┘   │
                    └───────────┼─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │   ScyllaDB / Cassandra  │
                    │   (Wide-Column Store)   │
                    └─────────────────────────┘
```

### Module Structure

```
libs/
├── platform/
│   ├── ... (existing)
│   └── platform-audit/              # NEW: Shared audit publishing library
│       ├── AuditEvent.java          # Event record
│       ├── AuditEventPublisher.java # Publisher interface
│       └── RedisStreamPublisher.java # Redis Streams implementation

apps/
├── ... (existing)
└── audit-service/                   # NEW: Audit data service
    ├── consumer/                    # Queue consumer
    ├── controller/                  # REST API
    ├── repository/                  # Cassandra/ScyllaDB repository
    ├── domain/                      # Domain models
    └── config/                      # Configuration
```

### Package Naming

| Module | Package |
|--------|---------|
| platform-audit | `org.example.platform.audit` |
| audit-service | `org.example.audit` |

---

## Phase 1: Shared Audit Library (platform-audit)

### 1.1 Audit Event Model

**Location:** `libs/platform/platform-audit/`

**Package:** `org.example.platform.audit`

```java
// AuditEvent.java - shared audit event structure
public record AuditEvent(
    String eventId,          // UUID - generated by publisher
    String eventType,        // e.g., "CART_CREATED", "PRODUCT_ADDED"
    String entityType,       // e.g., "CART", "PRODUCT", "ORDER"
    String entityId,         // e.g., cartId, orderId
    int storeNumber,         // Store context
    String userId,           // User who performed the action
    String sessionId,        // Session context
    String traceId,          // Distributed tracing ID
    Instant timestamp,       // When the event occurred
    Map<String, Object> data // Event-specific payload (JSON serializable)
) {
    public static AuditEvent create(
        String eventType,
        String entityType,
        String entityId,
        int storeNumber,
        String userId,
        String sessionId,
        String traceId,
        Map<String, Object> data
    ) {
        return new AuditEvent(
            UUID.randomUUID().toString(),
            eventType,
            entityType,
            entityId,
            storeNumber,
            userId,
            sessionId,
            traceId,
            Instant.now(),
            data
        );
    }
}

// AuditEventType.java - common event type constants
public final class AuditEventType {
    // Cart events
    public static final String CART_CREATED = "CART_CREATED";
    public static final String CART_DELETED = "CART_DELETED";
    public static final String CART_VIEWED = "CART_VIEWED";
    public static final String PRODUCT_ADDED = "PRODUCT_ADDED";
    public static final String PRODUCT_UPDATED = "PRODUCT_UPDATED";
    public static final String PRODUCT_REMOVED = "PRODUCT_REMOVED";
    public static final String CUSTOMER_SET = "CUSTOMER_SET";
    public static final String CUSTOMER_REMOVED = "CUSTOMER_REMOVED";
    public static final String DISCOUNT_APPLIED = "DISCOUNT_APPLIED";
    public static final String DISCOUNT_REMOVED = "DISCOUNT_REMOVED";
    public static final String FULFILLMENT_ADDED = "FULFILLMENT_ADDED";
    public static final String FULFILLMENT_UPDATED = "FULFILLMENT_UPDATED";
    public static final String FULFILLMENT_REMOVED = "FULFILLMENT_REMOVED";

    // Product events
    public static final String PRODUCT_VIEWED = "PRODUCT_VIEWED";

    // Future: Order events, Payment events, etc.

    private AuditEventType() {}
}

// EntityType.java - entity type constants
public final class EntityType {
    public static final String CART = "CART";
    public static final String PRODUCT = "PRODUCT";
    public static final String ORDER = "ORDER";
    public static final String CUSTOMER = "CUSTOMER";

    private EntityType() {}
}
```

### 1.2 Publisher Interface

```java
// AuditEventPublisher.java - interface for publishing audit events
public interface AuditEventPublisher {
    /**
     * Publishes an audit event asynchronously.
     * Returns immediately; failures are logged but do not propagate.
     */
    Mono<Void> publish(AuditEvent event);

    /**
     * Publishes an audit event and waits for acknowledgment.
     * Use when audit confirmation is required (rare).
     */
    Mono<String> publishAndAwait(AuditEvent event);
}
```

### 1.3 Redis Streams Publisher Implementation

```java
// RedisStreamAuditPublisher.java
@Component
@ConditionalOnProperty(name = "audit.enabled", havingValue = "true")
public class RedisStreamAuditPublisher implements AuditEventPublisher {

    private static final String STREAM_KEY = "audit-events";

    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger;
    private final ReactiveResilience resilience;

    @Override
    public Mono<Void> publish(AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            try {
                String json = objectMapper.writeValueAsString(event);
                Map<String, String> fields = Map.of(
                    "eventId", event.eventId(),
                    "payload", json
                );

                return redisTemplate.opsForStream()
                    .add(StreamRecords.newRecord()
                        .in(STREAM_KEY)
                        .ofMap(fields))
                    .then()
                    .transform(resilience.decorate("audit"))
                    .onErrorResume(e -> {
                        logger.warn(ctx, "Failed to publish audit event", Map.of(
                            "eventType", event.eventType(),
                            "entityId", event.entityId(),
                            "error", e.getMessage()
                        ));
                        return Mono.empty(); // Never fail the main operation
                    });
            } catch (JsonProcessingException e) {
                logger.error(ctx, "Failed to serialize audit event", Map.of(
                    "eventType", event.eventType(),
                    "error", e.getMessage()
                ));
                return Mono.empty();
            }
        });
    }

    @Override
    public Mono<String> publishAndAwait(AuditEvent event) {
        // Similar but returns the record ID for confirmation
    }
}

// NoOpAuditPublisher.java - for when audit is disabled
@Component
@ConditionalOnProperty(name = "audit.enabled", havingValue = "false", matchIfMissing = true)
public class NoOpAuditPublisher implements AuditEventPublisher {

    private final StructuredLogger logger = StructuredLogger.getLogger(NoOpAuditPublisher.class);

    @Override
    public Mono<Void> publish(AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            logger.debug(ctx, "Audit event (disabled)", Map.of(
                "eventType", event.eventType(),
                "entityId", event.entityId()
            ));
            return Mono.empty();
        });
    }

    @Override
    public Mono<String> publishAndAwait(AuditEvent event) {
        return Mono.just("noop-" + event.eventId());
    }
}
```

### 1.4 Auto-Configuration

```java
// AuditAutoConfiguration.java
@Configuration
@EnableConfigurationProperties(AuditProperties.class)
public class AuditAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public ObjectMapper auditObjectMapper() {
        return new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }
}

// AuditProperties.java
@ConfigurationProperties(prefix = "audit")
public record AuditProperties(
    boolean enabled,
    String streamKey,
    Duration publishTimeout
) {
    public AuditProperties() {
        this(false, "audit-events", Duration.ofMillis(500));
    }
}
```

---

## Phase 2: Audit Service Application

### 2.1 Application Setup

**Location:** `apps/audit-service/`

**Port:** 8086

**Dependencies:**
- platform-bom
- platform-logging
- platform-resilience
- platform-error
- platform-webflux
- platform-security
- platform-audit
- spring-boot-starter-webflux
- spring-boot-starter-data-redis-reactive
- spring-boot-starter-data-cassandra-reactive

### 2.2 Domain Models

```java
// AuditRecord.java - persisted audit record
@Table("audit_events")
public record AuditRecord(
    @PrimaryKeyColumn(name = "store_number", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    int storeNumber,

    @PrimaryKeyColumn(name = "entity_type", ordinal = 1, type = PrimaryKeyType.PARTITIONED)
    String entityType,

    @PrimaryKeyColumn(name = "timestamp", ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
    Instant timestamp,

    @PrimaryKeyColumn(name = "event_id", ordinal = 3, type = PrimaryKeyType.CLUSTERED)
    String eventId,

    @Column("event_type")
    String eventType,

    @Column("entity_id")
    String entityId,

    @Column("user_id")
    String userId,

    @Column("session_id")
    String sessionId,

    @Column("trace_id")
    String traceId,

    @Column("data")
    String data  // JSON string
) {
    public static AuditRecord fromEvent(AuditEvent event, ObjectMapper mapper) {
        String dataJson;
        try {
            dataJson = mapper.writeValueAsString(event.data());
        } catch (JsonProcessingException e) {
            dataJson = "{}";
        }
        return new AuditRecord(
            event.storeNumber(),
            event.entityType(),
            event.timestamp(),
            event.eventId(),
            event.eventType(),
            event.entityId(),
            event.userId(),
            event.sessionId(),
            event.traceId(),
            dataJson
        );
    }
}
```

### 2.3 Cassandra Schema

```cql
-- Keyspace
CREATE KEYSPACE IF NOT EXISTS audit
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};

-- Main audit events table
-- Partitioned by store_number + entity_type for efficient queries
-- Clustered by timestamp (descending) for time-series queries
CREATE TABLE IF NOT EXISTS audit.audit_events (
    store_number int,
    entity_type text,
    timestamp timestamp,
    event_id text,
    event_type text,
    entity_id text,
    user_id text,
    session_id text,
    trace_id text,
    data text,  -- JSON payload
    PRIMARY KEY ((store_number, entity_type), timestamp, event_id)
) WITH CLUSTERING ORDER BY (timestamp DESC, event_id ASC)
  AND default_time_to_live = 31536000  -- 1 year TTL
  AND compaction = {'class': 'TimeWindowCompactionStrategy', 'compaction_window_size': 1, 'compaction_window_unit': 'DAYS'};

-- Secondary index for entity lookups
CREATE TABLE IF NOT EXISTS audit.audit_events_by_entity (
    entity_type text,
    entity_id text,
    timestamp timestamp,
    event_id text,
    store_number int,
    event_type text,
    user_id text,
    session_id text,
    trace_id text,
    data text,
    PRIMARY KEY ((entity_type, entity_id), timestamp, event_id)
) WITH CLUSTERING ORDER BY (timestamp DESC, event_id ASC)
  AND default_time_to_live = 31536000;

-- Index for user activity
CREATE TABLE IF NOT EXISTS audit.audit_events_by_user (
    user_id text,
    timestamp timestamp,
    event_id text,
    store_number int,
    entity_type text,
    entity_id text,
    event_type text,
    session_id text,
    trace_id text,
    data text,
    PRIMARY KEY (user_id, timestamp, event_id)
) WITH CLUSTERING ORDER BY (timestamp DESC, event_id ASC)
  AND default_time_to_live = 31536000;
```

---

## Phase 3: Queue Consumer

### 3.1 Redis Streams Consumer

```java
// AuditEventConsumer.java
@Component
public class AuditEventConsumer {

    private static final String STREAM_KEY = "audit-events";
    private static final String CONSUMER_GROUP = "audit-service";
    private static final String CONSUMER_NAME = "audit-consumer-1";

    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final AuditRepository auditRepository;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger;

    @PostConstruct
    public void init() {
        // Create consumer group if not exists
        createConsumerGroup().subscribe();
    }

    @Scheduled(fixedDelay = 100) // Poll every 100ms
    public void consume() {
        readEvents()
            .flatMap(this::processEvent)
            .subscribe();
    }

    private Flux<MapRecord<String, String, String>> readEvents() {
        return redisTemplate.opsForStream()
            .read(Consumer.from(CONSUMER_GROUP, CONSUMER_NAME),
                  StreamReadOptions.empty().count(100).block(Duration.ofMillis(50)),
                  StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed()))
            .onErrorResume(e -> {
                logger.warn("Failed to read from stream", Map.of("error", e.getMessage()));
                return Flux.empty();
            });
    }

    private Mono<Void> processEvent(MapRecord<String, String, String> record) {
        return Mono.defer(() -> {
            String payload = record.getValue().get("payload");
            AuditEvent event = objectMapper.readValue(payload, AuditEvent.class);

            return auditRepository.save(event)
                .then(acknowledgeRecord(record))
                .doOnSuccess(v -> logger.debug("Processed audit event",
                    Map.of("eventId", event.eventId(), "eventType", event.eventType())))
                .onErrorResume(e -> {
                    logger.error("Failed to process audit event", Map.of(
                        "eventId", record.getValue().get("eventId"),
                        "error", e.getMessage()
                    ));
                    return Mono.empty(); // Don't ack, will be reprocessed
                });
        });
    }

    private Mono<Void> acknowledgeRecord(MapRecord<String, String, String> record) {
        return redisTemplate.opsForStream()
            .acknowledge(STREAM_KEY, CONSUMER_GROUP, record.getId())
            .then();
    }

    private Mono<Void> createConsumerGroup() {
        return redisTemplate.opsForStream()
            .createGroup(STREAM_KEY, CONSUMER_GROUP)
            .onErrorResume(e -> Mono.empty()); // Ignore if already exists
    }
}
```

### 3.2 Batch Processing Configuration

```yaml
# application.yml
audit:
  consumer:
    batch-size: 100
    poll-interval: 100ms
    max-retries: 3
    retry-delay: 1s

  stream:
    key: audit-events
    consumer-group: audit-service
    consumer-name: ${HOSTNAME:audit-consumer-1}
```

---

## Phase 4: REST API

### 4.1 API Endpoints

| Method | Path | Description | Request Body | Response |
|--------|------|-------------|--------------|----------|
| POST | `/audit/events` | Create audit event | `AuditEvent` | `AuditEvent` (201) |
| GET | `/audit/events/{eventId}` | Get event by ID | - | `AuditEvent` (200) |
| GET | `/audit/events` | Query events | Query params | `Page<AuditEvent>` |
| GET | `/audit/entities/{entityType}/{entityId}/events` | Events for entity | Query params | `List<AuditEvent>` |
| GET | `/audit/users/{userId}/events` | Events by user | Query params | `List<AuditEvent>` |
| GET | `/audit/stores/{storeNumber}/events` | Events by store | Query params | `List<AuditEvent>` |

### 4.2 Query Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `startTime` | ISO DateTime | Start of time range (inclusive) |
| `endTime` | ISO DateTime | End of time range (exclusive) |
| `eventType` | String | Filter by event type |
| `entityType` | String | Filter by entity type |
| `limit` | Integer | Max results (default 100, max 1000) |
| `pageToken` | String | Pagination token for next page |

### 4.3 Controller Implementation

```java
// AuditController.java
@RestController
@RequestMapping("/audit")
public class AuditController {

    private final AuditService auditService;
    private final StructuredLogger logger = StructuredLogger.getLogger(AuditController.class);

    // POST /audit/events - Direct event submission (secondary mechanism)
    @PostMapping("/events")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<AuditEvent> createEvent(@RequestBody AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            logger.info(ctx, "Creating audit event via API", Map.of(
                "eventType", event.eventType(),
                "entityId", event.entityId()
            ));
            return auditService.save(event);
        });
    }

    // GET /audit/events/{eventId}
    @GetMapping("/events/{eventId}")
    public Mono<AuditEvent> getEvent(@PathVariable String eventId) {
        return auditService.findById(eventId)
            .switchIfEmpty(Mono.error(new NotFoundException("Audit event not found")));
    }

    // GET /audit/entities/{entityType}/{entityId}/events
    @GetMapping("/entities/{entityType}/{entityId}/events")
    public Flux<AuditEvent> getEventsForEntity(
        @PathVariable String entityType,
        @PathVariable String entityId,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(required = false) String eventType,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByEntity(entityType, entityId,
            new TimeRange(startTime, endTime), eventType, limit);
    }

    // GET /audit/users/{userId}/events
    @GetMapping("/users/{userId}/events")
    public Flux<AuditEvent> getEventsForUser(
        @PathVariable String userId,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByUser(userId, new TimeRange(startTime, endTime), limit);
    }

    // GET /audit/stores/{storeNumber}/events
    @GetMapping("/stores/{storeNumber}/events")
    public Flux<AuditEvent> getEventsForStore(
        @PathVariable int storeNumber,
        @RequestParam String entityType,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(required = false) String eventType,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByStoreAndEntityType(storeNumber, entityType,
            new TimeRange(startTime, endTime), eventType, limit);
    }
}
```

---

## Phase 5: Repository Layer

### 5.1 Audit Repository Interface

```java
// AuditRepository.java
public interface AuditRepository {

    Mono<AuditEvent> save(AuditEvent event);

    Mono<AuditEvent> findById(String eventId);

    Flux<AuditEvent> findByEntity(
        String entityType,
        String entityId,
        TimeRange timeRange,
        String eventType,
        int limit
    );

    Flux<AuditEvent> findByUser(
        String userId,
        TimeRange timeRange,
        int limit
    );

    Flux<AuditEvent> findByStoreAndEntityType(
        int storeNumber,
        String entityType,
        TimeRange timeRange,
        String eventType,
        int limit
    );
}
```

### 5.2 Cassandra Repository Implementation

```java
// CassandraAuditRepository.java
@Repository
public class CassandraAuditRepository implements AuditRepository {

    private final ReactiveCassandraTemplate cassandraTemplate;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger;

    @Override
    public Mono<AuditEvent> save(AuditEvent event) {
        AuditRecord record = AuditRecord.fromEvent(event, objectMapper);

        // Write to all tables (denormalized for query efficiency)
        return Mono.when(
            cassandraTemplate.insert(record),
            saveToEntityIndex(event),
            saveToUserIndex(event)
        ).thenReturn(event);
    }

    @Override
    public Flux<AuditEvent> findByEntity(
        String entityType,
        String entityId,
        TimeRange timeRange,
        String eventType,
        int limit
    ) {
        String cql = buildEntityQuery(timeRange, eventType);
        return cassandraTemplate.select(cql, AuditRecord.class)
            .map(this::toEvent)
            .take(limit);
    }

    @Override
    public Flux<AuditEvent> findByStoreAndEntityType(
        int storeNumber,
        String entityType,
        TimeRange timeRange,
        String eventType,
        int limit
    ) {
        // Query the main table by partition key (store_number, entity_type)
        String cql = """
            SELECT * FROM audit_events
            WHERE store_number = ? AND entity_type = ?
            AND timestamp >= ? AND timestamp < ?
            """ + (eventType != null ? " AND event_type = ?" : "") +
            " LIMIT ?";

        return cassandraTemplate.select(cql, AuditRecord.class,
            storeNumber, entityType,
            timeRange.start(), timeRange.end(),
            eventType, limit)
            .map(this::toEvent);
    }

    private AuditEvent toEvent(AuditRecord record) {
        Map<String, Object> data;
        try {
            data = objectMapper.readValue(record.data(),
                new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            data = Map.of();
        }
        return new AuditEvent(
            record.eventId(),
            record.eventType(),
            record.entityType(),
            record.entityId(),
            record.storeNumber(),
            record.userId(),
            record.sessionId(),
            record.traceId(),
            record.timestamp(),
            data
        );
    }
}
```

---

## Phase 6: Resilience Configuration

### 6.1 Consumer Resilience

```yaml
resilience4j:
  circuitbreaker:
    instances:
      cassandra:
        registerHealthIndicator: true
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3

  retry:
    instances:
      cassandra:
        maxAttempts: 3
        waitDuration: 500ms
        exponentialBackoffMultiplier: 2
        retryExceptions:
          - com.datastax.oss.driver.api.core.AllNodesFailedException
          - com.datastax.oss.driver.api.core.connection.ConnectionException

  bulkhead:
    instances:
      consumer:
        maxConcurrentCalls: 50
      api:
        maxConcurrentCalls: 100
```

### 6.2 Dead Letter Queue

Events that fail processing after retries are moved to a dead letter stream:

```java
// DeadLetterHandler.java
@Component
public class DeadLetterHandler {

    private static final String DLQ_STREAM = "audit-events-dlq";

    public Mono<Void> handleFailedEvent(AuditEvent event, Throwable error) {
        return redisTemplate.opsForStream()
            .add(StreamRecords.newRecord()
                .in(DLQ_STREAM)
                .ofMap(Map.of(
                    "event", serialize(event),
                    "error", error.getMessage(),
                    "timestamp", Instant.now().toString()
                )))
            .then();
    }
}
```

---

## Phase 7: Security Configuration

### 7.1 OAuth2 Resource Server

```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                // Write access requires audit:write scope
                .pathMatchers(HttpMethod.POST, "/audit/**").hasAuthority("SCOPE_audit:write")
                // Read access requires audit:read scope
                .pathMatchers(HttpMethod.GET, "/audit/**").hasAuthority("SCOPE_audit:read")
                // Health/metrics
                .pathMatchers("/actuator/**").permitAll()
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
            .build();
    }
}
```

### 7.2 Service-to-Service Authentication

Services publishing audit events use client credentials:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          audit-publisher:
            client-id: ${service.name}
            client-secret: ${SERVICE_SECRET}
            scope: audit:write
            authorization-grant-type: client_credentials
```

---

## Phase 8: Logging & Observability

### 8.1 Structured Logging

```java
// Consumer logging
logger.info(ctx, "Processing audit event batch", Map.of(
    "batchSize", records.size(),
    "streamOffset", lastOffset
));

logger.debug(ctx, "Saved audit event", Map.of(
    "eventId", event.eventId(),
    "eventType", event.eventType(),
    "entityType", event.entityType(),
    "entityId", event.entityId(),
    "latencyMs", processingTime
));

logger.warn(ctx, "Failed to process audit event", Map.of(
    "eventId", event.eventId(),
    "error", exception.getMessage(),
    "retryCount", retryCount
));
```

### 8.2 Metrics

| Metric | Type | Description |
|--------|------|-------------|
| `audit_events_received_total` | Counter | Events received from queue |
| `audit_events_processed_total` | Counter | Events successfully processed |
| `audit_events_failed_total` | Counter | Events that failed processing |
| `audit_events_dlq_total` | Counter | Events sent to dead letter queue |
| `audit_processing_latency_seconds` | Histogram | Event processing time |
| `audit_queue_lag` | Gauge | Number of pending events |
| `audit_api_requests_total` | Counter | REST API requests by endpoint |

---

## Phase 9: Testing Strategy

### 9.1 Unit Tests

- Event serialization/deserialization
- Repository query building
- Consumer batch processing logic

### 9.2 Integration Tests

- Redis Streams consumer tests with embedded Redis
- Cassandra repository tests with Testcontainers
- Full API tests with WebTestClient

### 9.3 Contract Tests

- Publisher → Consumer contract (event format)
- API contract for query endpoints

### 9.4 Load Tests (k6)

- High-volume event ingestion
- Query performance under load
- Consumer lag scenarios

---

## Implementation Order

### Step 1: Platform Audit Library
1. Create `libs/platform/platform-audit/` directory
2. Implement `AuditEvent` record
3. Implement `AuditEventPublisher` interface
4. Implement `RedisStreamAuditPublisher`
5. Implement `NoOpAuditPublisher`
6. Add auto-configuration
7. Update `settings.gradle.kts`

### Step 2: Audit Service Setup
1. Create `apps/audit-service/` directory
2. Create `build.gradle.kts` with dependencies
3. Create application bootstrap class
4. Configure Cassandra connection
5. Configure Redis Streams connection

### Step 3: Database Schema
1. Create Cassandra keyspace and tables
2. Implement `AuditRecord` domain model
3. Implement `CassandraAuditRepository`

### Step 4: Queue Consumer
1. Implement `AuditEventConsumer`
2. Add batch processing
3. Add retry logic
4. Add dead letter handling

### Step 5: REST API
1. Implement `AuditController`
2. Implement query endpoints
3. Add validation
4. Add pagination

### Step 6: Integration with Cart Service
1. Add `platform-audit` dependency to cart-service
2. Replace `NoOpAuditEventPublisher` with `RedisStreamAuditPublisher`
3. Enable audit publishing via configuration
4. Test end-to-end flow

### Step 7: Security
1. Configure OAuth2 resource server
2. Add scope-based access control
3. Test security

### Step 8: Observability
1. Add metrics
2. Add Grafana dashboards
3. Add alerting rules

### Step 9: Docker & Testing
1. Add Cassandra to Docker Compose
2. Update audit-service Docker configuration
3. Write integration tests
4. Write load tests

---

## File Checklist

### New Files to Create

**Platform Audit Library:**
- [ ] `libs/platform/platform-audit/build.gradle.kts`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEvent.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEventType.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/EntityType.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEventPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/RedisStreamAuditPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/NoOpAuditPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditAutoConfiguration.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditProperties.java`
- [ ] `libs/platform/platform-audit/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`

**Audit Service:**
- [ ] `apps/audit-service/build.gradle.kts`
- [ ] `apps/audit-service/src/main/java/org/example/audit/AuditServiceApplication.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/domain/AuditRecord.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/domain/TimeRange.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/repository/AuditRepository.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/repository/CassandraAuditRepository.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/consumer/AuditEventConsumer.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/consumer/DeadLetterHandler.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/service/AuditService.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/controller/AuditController.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/SecurityConfig.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/CassandraConfig.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/RedisStreamConfig.java`
- [ ] `apps/audit-service/src/main/resources/application.yml`
- [ ] `apps/audit-service/src/main/resources/schema.cql`

**Docker:**
- [ ] `docker/cassandra/init.cql` (schema initialization)

**Configuration Updates:**
- [ ] `settings.gradle.kts` (add new modules)
- [ ] `docker/docker-compose.yml` (add Cassandra, audit-service)

### Files to Modify

- [ ] `apps/cart-service/build.gradle.kts` - add platform-audit dependency
- [ ] `apps/cart-service/src/main/resources/application.yml` - add audit configuration
- [ ] `apps/cart-service/src/main/java/org/example/cart/audit/` - remove local implementations, use platform-audit

---

## Docker Compose Additions

```yaml
# docker-compose.yml additions

cassandra:
  image: cassandra:4.1
  container_name: cassandra
  ports:
    - "9042:9042"
  environment:
    - CASSANDRA_CLUSTER_NAME=audit-cluster
    - CASSANDRA_DC=dc1
  volumes:
    - cassandra-data:/var/lib/cassandra
    - ./cassandra/init.cql:/docker-entrypoint-initdb.d/init.cql
  healthcheck:
    test: ["CMD", "cqlsh", "-e", "describe keyspaces"]
    interval: 30s
    timeout: 10s
    retries: 5

audit-service:
  build:
    context: ..
    dockerfile: apps/audit-service/Dockerfile
  container_name: audit-service
  ports:
    - "8086:8080"
  environment:
    - SPRING_PROFILES_ACTIVE=docker
    - SPRING_DATA_CASSANDRA_CONTACT_POINTS=cassandra
    - SPRING_DATA_REDIS_HOST=redis
  depends_on:
    cassandra:
      condition: service_healthy
    redis:
      condition: service_started
  labels:
    - "prometheus.scrape=true"
    - "prometheus.port=8080"
    - "prometheus.path=/actuator/prometheus"

volumes:
  cassandra-data:
```

---

## Open Questions

1. **Data Retention:** How long should audit data be retained?
   - **Proposed:** 1 year TTL in Cassandra, configurable per event type

2. **Event Ordering:** Is strict ordering required within an entity?
   - **Proposed:** Best-effort ordering via timestamp; exact ordering available via eventId

3. **PII Handling:** Should audit events contain PII or reference external stores?
   - **Proposed:** Minimal PII (userId, sessionId); sensitive data references only

4. **Query Access Control:** Should users only see their own audit events?
   - **Proposed:** Scope-based; `audit:read` for service accounts, user-scoped access for end users

5. **Real-time Subscriptions:** Should clients be able to subscribe to audit events?
   - **Proposed:** Future enhancement; add WebSocket/SSE endpoint for real-time streaming

6. **Cross-Service Correlation:** How to correlate events across services?
   - **Proposed:** Use `traceId` from OpenTelemetry for distributed tracing correlation

7. **Cassandra vs ScyllaDB:** Which wide-column database to use?
   - **Proposed:** Start with Cassandra for familiarity; ScyllaDB is drop-in compatible for future migration
