#!/usr/bin/env node

/**
 * powerstart - Start all reactive-platform services
 * A simple way to bring up the entire platform for local development
 *
 * Run './powerstart --help' for full documentation and examples.
 */

import { execSync, spawn } from 'child_process';
import { existsSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import * as readline from 'readline';

const __dirname = dirname(fileURLToPath(import.meta.url));
const DOCKER_DIR = join(__dirname, 'docker');

// All available apps that can be rebuilt/restarted
const ALL_APPS = {
  // Backend services (Docker)
  'product-service': { port: 8090, type: 'backend', docker: 'product-service' },
  'cart-service': { port: 8081, type: 'backend', docker: 'cart-service' },
  'customer-service': { port: 8083, type: 'backend', docker: 'customer-service' },
  'discount-service': { port: 8084, type: 'backend', docker: 'discount-service' },
  'fulfillment-service': { port: 8085, type: 'backend', docker: 'fulfillment-service' },
  'audit-service': { port: 8086, type: 'backend', docker: 'audit-service' },
  'checkout-service': { port: 8087, type: 'backend', docker: 'checkout-service' },
  'order-service': { port: 8088, type: 'backend', docker: 'order-service' },
  'user-service': { port: 8089, type: 'backend', docker: 'user-service' },
  // Peripheral emulator (Docker)
  'peripheral-emulator': { port: 9100, type: 'emulator', docker: 'peripheral-emulator', httpPort: 9101 },
  // Frontend apps (some Docker, some local)
  'ecommerce-web': { port: 3001, type: 'frontend', docker: 'ecommerce-web' },
  'kiosk-web': { port: 3002, type: 'frontend', docker: null }, // runs locally via nx serve
  'home-portal': { port: 3003, type: 'frontend', docker: null }, // runs locally via nx serve
};

// Service groups for interactive mode
const SERVICE_GROUPS = {
  'frontend': {
    name: 'Frontend/Web',
    description: 'ecommerce-web, kiosk-web, home-portal',
    default: true,
  },
  'backends': {
    name: 'Backends + Infrastructure',
    description: 'All backend services + PostgreSQL, Redis',
    default: true,
  },
  'observability': {
    name: 'Observability (Grafana Stack)',
    description: 'Grafana, Prometheus, Loki, Tempo',
    default: false,
  },
  'mocks': {
    name: 'Mocks (WireMock)',
    description: 'WireMock for external service mocks',
    default: false,
  },
};

// Built-in profiles for quick startup configurations
const PROFILES = {
  'full': {
    name: 'Full Stack',
    description: 'Everything: frontend, backends, observability, mocks',
    selections: { frontend: true, backends: true, observability: true, mocks: true },
  },
  'dev': {
    name: 'Development',
    description: 'Frontend + backends (default)',
    selections: { frontend: true, backends: true, observability: false, mocks: false },
  },
  'backend': {
    name: 'Backend Only',
    description: 'All backend services without frontend',
    selections: { frontend: false, backends: true, observability: false, mocks: false },
  },
  'frontend': {
    name: 'Frontend Only',
    description: 'Frontend apps only (requires backends running)',
    selections: { frontend: true, backends: false, observability: false, mocks: false },
  },
  'minimal': {
    name: 'Minimal',
    description: 'Infrastructure only: PostgreSQL, Redis',
    selections: { frontend: false, backends: false, observability: false, mocks: false },
    infraOnly: true,
  },
};

// All services with their ports and health endpoints for status checks
const ALL_SERVICES = [
  { name: 'PostgreSQL', port: 5432, group: 'infra', docker: 'postgres' },
  { name: 'Redis', port: 6379, group: 'infra', docker: 'redis' },
  { name: 'WireMock', port: 8082, group: 'mocks', docker: 'wiremock', healthEndpoint: '/__admin/mappings' },
  { name: 'product-service', port: 8090, group: 'backends', docker: 'product-service' },
  { name: 'cart-service', port: 8081, group: 'backends', docker: 'cart-service' },
  { name: 'customer-service', port: 8083, group: 'backends', docker: 'customer-service' },
  { name: 'discount-service', port: 8084, group: 'backends', docker: 'discount-service' },
  { name: 'fulfillment-service', port: 8085, group: 'backends', docker: 'fulfillment-service' },
  { name: 'audit-service', port: 8086, group: 'backends', docker: 'audit-service' },
  { name: 'checkout-service', port: 8087, group: 'backends', docker: 'checkout-service' },
  { name: 'order-service', port: 8088, group: 'backends', docker: 'order-service' },
  { name: 'user-service', port: 8089, group: 'backends', docker: 'user-service' },
  { name: 'peripheral-emulator', port: 9101, group: 'backends', docker: 'peripheral-emulator', healthEndpoint: '/control/state' },
  { name: 'Grafana', port: 3000, group: 'observability', docker: 'grafana', healthEndpoint: '/api/health' },
  { name: 'Prometheus', port: 9090, group: 'observability', docker: 'prometheus' },
  { name: 'Loki', port: 3100, group: 'observability', docker: 'loki' },
  { name: 'Tempo', port: 3200, group: 'observability', docker: 'tempo' },
  { name: 'ecommerce-web', port: 3001, group: 'frontend', docker: 'ecommerce-web', healthEndpoint: '/' },
  { name: 'kiosk-web', port: 3002, group: 'frontend', docker: null, healthEndpoint: '/' },
  { name: 'home-portal', port: 3003, group: 'frontend', docker: null, healthEndpoint: '/' },
];

// ANSI colors
const colors = {
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[1;33m',
  blue: '\x1b[0;34m',
  cyan: '\x1b[0;36m',
  magenta: '\x1b[0;35m',
  gray: '\x1b[0;90m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  nc: '\x1b[0m',
};

// Track state
const startedServices = [];
const failedServices = [];
const alreadyRunning = new Set();

// Logging functions
function logHeader(msg) {
  console.log('');
  console.log(`${colors.bold}${colors.blue}${'═'.repeat(62)}${colors.nc}`);
  console.log(`${colors.bold}${colors.blue}  ${msg}${colors.nc}`);
  console.log(`${colors.bold}${colors.blue}${'═'.repeat(62)}${colors.nc}`);
}

function logStep(msg) {
  console.log(`${colors.cyan}▶${colors.nc} ${msg}`);
}

function logSuccess(msg) {
  console.log(`${colors.green}✓${colors.nc} ${msg}`);
}

function logWarning(msg) {
  console.log(`${colors.yellow}⚠${colors.nc} ${msg}`);
}

function logError(msg) {
  console.log(`${colors.red}✗${colors.nc} ${msg}`);
}

function logInfo(msg) {
  console.log(`${colors.blue}ℹ${colors.nc} ${msg}`);
}

// ============================================================================
// STOP COMMAND
// ============================================================================

async function stopServices(group = null) {
  logHeader(group ? `Stopping ${group} Services` : 'Stopping All Services');

  // Kill local processes (kiosk-web, home-portal on their ports)
  const localPorts = [3002, 3003]; // kiosk-web, home-portal
  for (const port of localPorts) {
    const pid = execSilent(`lsof -i :${port} -t`).trim().split('\n')[0];
    if (pid) {
      logStep(`Stopping local process on port ${port}...`);
      try {
        execSync(`kill ${pid}`, { stdio: 'pipe' });
        logSuccess(`Stopped process on port ${port}`);
      } catch {
        // Process may have already stopped
      }
    }
  }

  // Stop Docker services
  logStep('Stopping Docker services...');

  if (group) {
    // Stop specific group
    const groupServices = ALL_SERVICES.filter(s => s.group === group && s.docker);
    if (groupServices.length > 0) {
      const dockerServices = groupServices.map(s => s.docker).join(' ');
      exec(`docker compose stop ${dockerServices}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    }
  } else {
    // Stop all
    exec('docker compose down', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  }

  logSuccess(group ? `${group} services stopped` : 'All services stopped');
}

// ============================================================================
// STATUS COMMAND
// ============================================================================

async function showStatus() {
  console.log('');
  console.log(`${colors.bold}Service Status${colors.nc}`);
  console.log(`${'─'.repeat(60)}`);

  const groupOrder = ['infra', 'backends', 'mocks', 'observability', 'frontend'];
  const groupNames = {
    infra: 'Infrastructure',
    backends: 'Backend Services',
    mocks: 'Mocks',
    observability: 'Observability',
    frontend: 'Frontend',
  };

  let totalRunning = 0;
  let totalStopped = 0;

  for (const group of groupOrder) {
    const services = ALL_SERVICES.filter(s => s.group === group);
    if (services.length === 0) continue;

    console.log('');
    console.log(`${colors.bold}${groupNames[group]}:${colors.nc}`);

    for (const service of services) {
      const running = isPortInUse(service.port);
      const status = running ? `${colors.green}● running${colors.nc}` : `${colors.gray}○ stopped${colors.nc}`;
      const portInfo = `${colors.dim}:${service.port}${colors.nc}`;

      // Check health if running and has health endpoint
      let healthStatus = '';
      if (running && service.healthEndpoint) {
        const healthy = await isHealthy(service.port, service.healthEndpoint);
        healthStatus = healthy ? ` ${colors.green}(healthy)${colors.nc}` : ` ${colors.yellow}(unhealthy)${colors.nc}`;
      }

      console.log(`  ${status} ${service.name.padEnd(22)} ${portInfo}${healthStatus}`);

      if (running) totalRunning++;
      else totalStopped++;
    }
  }

  console.log('');
  console.log(`${'─'.repeat(60)}`);
  console.log(`${colors.green}Running: ${totalRunning}${colors.nc}  ${colors.gray}Stopped: ${totalStopped}${colors.nc}`);
  console.log('');
}

// ============================================================================
// LOGS COMMAND
// ============================================================================

function showLogs(serviceName, follow = true) {
  if (!serviceName) {
    logError('Service name required. Usage: ./powerstart -l <service>');
    logInfo(`Available services: ${ALL_SERVICES.filter(s => s.docker).map(s => s.docker).join(', ')}`);
    process.exit(1);
  }

  // Find the service
  const service = ALL_SERVICES.find(s =>
    s.docker === serviceName ||
    s.name.toLowerCase() === serviceName.toLowerCase() ||
    s.name.toLowerCase().includes(serviceName.toLowerCase())
  );

  if (!service || !service.docker) {
    logError(`Unknown or non-Docker service: ${serviceName}`);
    logInfo(`Available Docker services: ${ALL_SERVICES.filter(s => s.docker).map(s => s.docker).join(', ')}`);
    process.exit(1);
  }

  const followFlag = follow ? '-f' : '';
  logInfo(`Showing logs for ${service.name}... (Ctrl+C to exit)`);
  console.log('');

  try {
    execSync(`docker compose logs ${followFlag} ${service.docker}`, {
      cwd: DOCKER_DIR,
      stdio: 'inherit',
    });
  } catch {
    // User pressed Ctrl+C
  }
}

// ============================================================================
// HEALTH CHECK COMMAND
// ============================================================================

async function checkHealth() {
  console.log('');
  console.log(`${colors.bold}Health Check${colors.nc}`);
  console.log(`${'─'.repeat(60)}`);

  let healthy = 0;
  let unhealthy = 0;
  let stopped = 0;

  for (const service of ALL_SERVICES) {
    const running = isPortInUse(service.port);

    if (!running) {
      console.log(`  ${colors.gray}○${colors.nc} ${service.name.padEnd(22)} ${colors.gray}not running${colors.nc}`);
      stopped++;
      continue;
    }

    const endpoint = service.healthEndpoint || '/actuator/health';
    const isOk = await isHealthy(service.port, endpoint);

    if (isOk) {
      console.log(`  ${colors.green}✓${colors.nc} ${service.name.padEnd(22)} ${colors.green}healthy${colors.nc}`);
      healthy++;
    } else {
      console.log(`  ${colors.red}✗${colors.nc} ${service.name.padEnd(22)} ${colors.red}unhealthy${colors.nc} (${endpoint})`);
      unhealthy++;
    }
  }

  console.log('');
  console.log(`${'─'.repeat(60)}`);
  console.log(`${colors.green}Healthy: ${healthy}${colors.nc}  ${colors.red}Unhealthy: ${unhealthy}${colors.nc}  ${colors.gray}Stopped: ${stopped}${colors.nc}`);
  console.log('');

  return unhealthy === 0;
}

// ============================================================================
// CLEANUP COMMAND
// ============================================================================

async function cleanup(removeVolumes = false) {
  logHeader('Cleaning Up');

  // Stop all services first
  await stopServices();

  if (removeVolumes) {
    logStep('Removing Docker volumes...');
    exec('docker compose down -v', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    logSuccess('Volumes removed');
  }

  logStep('Pruning unused Docker resources...');
  exec('docker system prune -f', { silent: true, ignoreError: true });
  logSuccess('Docker resources pruned');

  logStep('Removing orphaned containers...');
  exec('docker compose rm -f', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Orphaned containers removed');

  logSuccess('Cleanup complete');
}

// ============================================================================
// OPEN BROWSER COMMAND
// ============================================================================

function openBrowser(url = 'http://localhost:3003') {
  logStep(`Opening ${url} in browser...`);
  try {
    // macOS
    execSync(`open "${url}"`, { stdio: 'pipe' });
    logSuccess('Browser opened');
  } catch {
    try {
      // Linux
      execSync(`xdg-open "${url}"`, { stdio: 'pipe' });
      logSuccess('Browser opened');
    } catch {
      logWarning(`Could not open browser. Please visit: ${url}`);
    }
  }
}

// ============================================================================
// MINIMAL INFRASTRUCTURE START
// ============================================================================

async function startMinimalInfra() {
  logHeader('Starting Minimal Infrastructure');

  logStep('Starting PostgreSQL and Redis...');
  exec('docker compose up -d postgres redis', { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  // Wait for postgres
  logStep('Waiting for PostgreSQL...');
  let ready = false;
  for (let i = 0; i < 30; i++) {
    try {
      execSilent('docker compose exec -T postgres pg_isready -U postgres');
      ready = true;
      break;
    } catch {
      await sleep(1000);
    }
  }
  if (ready) {
    logSuccess('PostgreSQL is ready');
  } else {
    logError('PostgreSQL failed to start');
  }

  // Wait for redis
  logStep('Waiting for Redis...');
  ready = false;
  for (let i = 0; i < 30; i++) {
    try {
      execSilent('docker compose exec -T redis redis-cli ping');
      ready = true;
      break;
    } catch {
      await sleep(1000);
    }
  }
  if (ready) {
    logSuccess('Redis is ready');
  } else {
    logError('Redis failed to start');
  }

  console.log('');
  logSuccess('Minimal infrastructure ready');
  console.log(`  ${colors.cyan}PostgreSQL${colors.nc}  localhost:5432`);
  console.log(`  ${colors.cyan}Redis${colors.nc}       localhost:6379`);
}

// Execute command and return output
function exec(cmd, options = {}) {
  try {
    return execSync(cmd, { encoding: 'utf8', stdio: options.silent ? 'pipe' : 'inherit', ...options });
  } catch (e) {
    if (options.ignoreError) return e.stdout || '';
    throw e;
  }
}

// Execute command silently and return output
function execSilent(cmd) {
  try {
    return execSync(cmd, { encoding: 'utf8', stdio: 'pipe' });
  } catch {
    return '';
  }
}

// Check if a port is in use
function isPortInUse(port) {
  const result = execSilent(`lsof -i :${port} -t`);
  return result.trim().length > 0;
}

// Get PID using a port
function getPortUser(port) {
  return execSilent(`lsof -i :${port} -t`).trim().split('\n')[0];
}

// Get process name by PID
function getProcessName(pid) {
  if (!pid) return 'unknown';
  return execSilent(`ps -p ${pid} -o comm=`).trim() || 'unknown';
}

// Check if a Docker container is using a port
function getContainerOnPort(port) {
  const result = execSilent(`docker ps --filter "publish=${port}" --format "{{.Names}}"`);
  return result.trim().split('\n')[0];
}

// Check if a service health endpoint is responding
async function isHealthy(port, endpoint = '/actuator/health') {
  try {
    const response = await fetch(`http://localhost:${port}${endpoint}`, { signal: AbortSignal.timeout(2000) });
    return response.ok;
  } catch {
    return false;
  }
}

// Wait for a service to be healthy
async function waitForHealth(serviceName, port, endpoint = '/actuator/health', maxRetries = 90) {
  process.stdout.write(`  Waiting for ${serviceName}...`);

  for (let i = 0; i < maxRetries; i++) {
    if (await isHealthy(port, endpoint)) {
      console.log(` ${colors.green}✓${colors.nc}`);
      return true;
    }
    await sleep(2000);
  }

  console.log(` ${colors.red}✗${colors.nc}`);
  return false;
}

// Sleep helper
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Check prerequisites
function checkPrerequisites() {
  logHeader('Checking Prerequisites');

  // Check Docker
  try {
    execSilent('docker --version');
    logSuccess('Docker is available');
  } catch {
    logError('Docker is not installed or not in PATH');
    process.exit(1);
  }

  // Check Docker daemon
  try {
    execSilent('docker info');
    logSuccess('Docker daemon is running');
  } catch {
    logError('Docker daemon is not running');
    process.exit(1);
  }

  // Check docker compose
  try {
    execSilent('docker compose version');
    logSuccess('Docker Compose is available');
  } catch {
    logError('Docker Compose is not available');
    process.exit(1);
  }

  // Check docker-compose.yml exists
  if (!existsSync(join(DOCKER_DIR, 'docker-compose.yml'))) {
    logError(`docker-compose.yml not found in ${DOCKER_DIR}`);
    process.exit(1);
  }
  logSuccess('docker-compose.yml found');
}

// Prompt user for yes/no confirmation
async function promptConfirm(message) {
  const rl = createReadlineInterface();
  return new Promise((resolve) => {
    rl.question(`${colors.yellow}${message} [y/N]: ${colors.nc}`, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

// Check for port conflicts
async function checkPortConflicts() {
  logHeader('Checking for Port Conflicts');

  const ports = [
    { port: 5432, service: 'PostgreSQL' },
    { port: 6379, service: 'Redis' },
    { port: 8090, service: 'product-service' },
    { port: 8081, service: 'cart-service' },
    { port: 8082, service: 'WireMock' },
    { port: 8083, service: 'customer-service' },
    { port: 8084, service: 'discount-service' },
    { port: 8085, service: 'fulfillment-service' },
    { port: 8086, service: 'audit-service' },
    { port: 8087, service: 'checkout-service' },
    { port: 8088, service: 'order-service' },
    { port: 8089, service: 'user-service' },
    { port: 8091, service: 'merchandise-service' },
    { port: 8092, service: 'price-service' },
    { port: 8093, service: 'inventory-service' },
    { port: 9100, service: 'peripheral-emulator (WebSocket)' },
    { port: 9101, service: 'peripheral-emulator (HTTP)' },
    { port: 3000, service: 'Grafana' },
    { port: 3001, service: 'ecommerce-web' },
    { port: 3002, service: 'kiosk-web' },
    { port: 3003, service: 'home-portal' },
    { port: 3010, service: 'merchant-portal' },
  ];

  const conflicts = [];

  for (const { port, service } of ports) {
    if (isPortInUse(port)) {
      const container = getContainerOnPort(port);
      if (container) {
        alreadyRunning.add(service);
        logInfo(`${service} already running on port ${port} (container: ${container})`);
      } else {
        const pid = getPortUser(port);
        const processName = getProcessName(pid);
        conflicts.push({ port, service, pid, processName });
      }
    }
  }

  if (conflicts.length > 0) {
    logError('Port conflicts detected!');
    console.log('');
    console.log(`${colors.red}The following ports are in use by other processes:${colors.nc}`);
    for (const { port, service, pid, processName } of conflicts) {
      console.log(`  ${colors.red}✗${colors.nc} Port ${port} (${service}) - used by PID ${pid} (${processName})`);
    }
    console.log('');

    // Ask user if they want to kill the conflicting processes
    const shouldKill = await promptConfirm('Kill these processes and continue?');

    if (shouldKill) {
      console.log('');
      for (const { port, service, pid, processName } of conflicts) {
        logStep(`Killing ${processName} (PID ${pid}) on port ${port} for ${service}...`);
        try {
          execSync(`kill -9 ${pid}`, { stdio: 'pipe' });
          logSuccess(`Killed ${processName} (PID ${pid}) - port ${port} now free for ${service}`);
        } catch {
          logWarning(`Could not kill process ${pid} for ${service}`);
        }
      }
      // Give processes time to release ports
      await sleep(1000);
      console.log('');
      logSuccess('Conflicting processes killed - continuing startup');
    } else {
      console.log('');
      console.log(`${colors.yellow}Startup cancelled. To resolve manually:${colors.nc}`);
      console.log('  1. Stop the conflicting processes');
      console.log('  2. Stop any running E2E stack: docker compose -f docker/docker-compose.e2e.yml down');
      console.log('  3. Stop any running dev stack: docker compose -f docker/docker-compose.yml down');
      console.log('');
      process.exit(1);
    }
  }

  if (alreadyRunning.size > 0) {
    logSuccess('Some services already running - will skip starting them');
  } else {
    logSuccess('All ports are available');
  }
}

// Build JARs
function buildJars() {
  logHeader('Building Application JARs');

  logStep('Building bootJars for all services...');
  logInfo('This may take a few minutes on first run');

  try {
    exec('./gradlew bootJar --parallel -q', { cwd: __dirname });
    logSuccess('All JARs built successfully');
  } catch {
    logError('JAR build failed');
    process.exit(1);
  }
}

// Start infrastructure services
async function startInfrastructure() {
  logHeader('Starting Infrastructure Services');

  const toStart = [];
  if (!alreadyRunning.has('PostgreSQL')) toStart.push('postgres');
  if (!alreadyRunning.has('Redis')) toStart.push('redis');
  if (!alreadyRunning.has('WireMock')) toStart.push('wiremock');

  if (toStart.length === 0) {
    logSuccess('All infrastructure services already running');
    startedServices.push('postgres:5432', 'redis:6379', 'wiremock:8082');
    return;
  }

  logStep(`Starting ${toStart.join(', ')}...`);
  exec(`docker compose up -d ${toStart.join(' ')}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Infrastructure containers started');

  logStep('Waiting for infrastructure to be healthy...');

  // Wait for postgres
  if (!alreadyRunning.has('PostgreSQL')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T postgres pg_isready -U postgres`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('PostgreSQL is ready');
      startedServices.push('postgres:5432');
    } else {
      logError('PostgreSQL failed to start');
      failedServices.push('postgres');
    }
  } else {
    startedServices.push('postgres:5432');
  }

  // Wait for redis
  if (!alreadyRunning.has('Redis')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T redis redis-cli ping`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('Redis is ready');
      startedServices.push('redis:6379');
    } else {
      logError('Redis failed to start');
      failedServices.push('redis');
    }
  } else {
    startedServices.push('redis:6379');
  }

  // Wait for wiremock
  if (!alreadyRunning.has('WireMock')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      if (await isHealthy(8082, '/__admin/mappings')) {
        ready = true;
        break;
      }
      await sleep(1000);
    }
    if (ready) {
      logSuccess('WireMock is ready');
      startedServices.push('wiremock:8082');
    } else {
      logError('WireMock failed to start');
      failedServices.push('wiremock');
    }
  } else {
    startedServices.push('wiremock:8082');
  }
}

// Start observability stack
async function startObservability() {
  logHeader('Starting Observability Stack');

  logStep('Starting Tempo, Loki, Prometheus, and Grafana...');
  exec('docker compose up -d tempo loki prometheus grafana promtail redis-exporter', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Observability containers started');

  logStep('Waiting for observability stack to be healthy...');

  // Wait for grafana
  let ready = false;
  for (let i = 0; i < 60; i++) {
    if (await isHealthy(3000, '/api/health')) {
      ready = true;
      break;
    }
    await sleep(2000);
  }

  if (ready) {
    logSuccess('Grafana is ready');
    startedServices.push('grafana:3000', 'prometheus:9090', 'loki:3100', 'tempo:3200');
  } else {
    logWarning('Grafana may not be fully ready yet');
  }
}

// Start peripheral emulator
async function startPeripheralEmulator() {
  logHeader('Starting Peripheral Emulator');

  if (alreadyRunning.has('peripheral-emulator (WebSocket)')) {
    logSuccess('peripheral-emulator already running');
    startedServices.push('peripheral-emulator:9100', 'peripheral-emulator-http:9101');
    return;
  }

  logStep('Starting peripheral-emulator...');
  exec('docker compose up -d peripheral-emulator', { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  logStep('Waiting for peripheral-emulator to be healthy...');
  if (await waitForHealth('peripheral-emulator', 9101, '/control/state')) {
    startedServices.push('peripheral-emulator:9100', 'peripheral-emulator-http:9101');
  } else {
    failedServices.push('peripheral-emulator');
  }
}

// Start backend services
async function startBackendServices() {
  logHeader('Starting Backend Services');

  const services = [
    // Core services (no service dependencies, just infra)
    { name: 'merchandise-service', port: 8091 },
    { name: 'price-service', port: 8092 },
    { name: 'inventory-service', port: 8093 },
    { name: 'customer-service', port: 8083 },
    { name: 'discount-service', port: 8084 },
    { name: 'fulfillment-service', port: 8085 },
    { name: 'audit-service', port: 8086 },
    { name: 'user-service', port: 8089 },
    // Aggregation services (depend on core services)
    { name: 'product-service', port: 8090 },
    { name: 'cart-service', port: 8081 },
    { name: 'checkout-service', port: 8087 },
    { name: 'order-service', port: 8088 },
  ];

  const toStart = services.filter(s => !alreadyRunning.has(s.name)).map(s => s.name);

  if (toStart.length === 0) {
    logSuccess('All backend services already running');
    services.forEach(s => startedServices.push(`${s.name}:${s.port}`));
    return;
  }

  logStep(`Starting ${toStart.length} backend services: ${toStart.join(', ')}...`);
  exec(`docker compose up -d ${toStart.join(' ')}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  logStep('Waiting for backend services to be healthy (this may take 1-2 minutes)...');

  for (const { name, port } of services) {
    if (alreadyRunning.has(name)) {
      console.log(`  ${name}... ${colors.green}✓${colors.nc} (already running)`);
      startedServices.push(`${name}:${port}`);
      continue;
    }

    if (await waitForHealth(name, port)) {
      startedServices.push(`${name}:${port}`);
    } else {
      failedServices.push(name);
    }
  }
}

// Start frontend applications
async function startFrontend() {
  logHeader('Starting Frontend Applications');

  // Start ecommerce-web (Docker)
  if (alreadyRunning.has('ecommerce-web')) {
    logSuccess('ecommerce-web already running');
    startedServices.push('ecommerce-web:3001');
  } else {
    logStep('Starting ecommerce-web...');
    exec('docker compose up -d ecommerce-web', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    logSuccess('ecommerce-web container started');

    logStep('Waiting for ecommerce-web to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3001, '/health') || await isHealthy(3001, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('ecommerce-web is ready');
    } else {
      logWarning('ecommerce-web may not be fully ready yet');
    }
    startedServices.push('ecommerce-web:3001');
  }

  // Start merchant-portal (Docker)
  if (alreadyRunning.has('merchant-portal')) {
    logSuccess('merchant-portal already running');
    startedServices.push('merchant-portal:3010');
  } else {
    logStep('Starting merchant-portal...');
    exec('docker compose up -d merchant-portal', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    logSuccess('merchant-portal container started');

    logStep('Waiting for merchant-portal to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3010, '/health') || await isHealthy(3010, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('merchant-portal is ready');
    } else {
      logWarning('merchant-portal may not be fully ready yet');
    }
    startedServices.push('merchant-portal:3010');
  }

  // Start kiosk-web (self-checkout kiosk application)
  if (alreadyRunning.has('kiosk-web')) {
    logSuccess('kiosk-web already running');
    startedServices.push('kiosk-web:3002');
  } else {
    logStep('Starting kiosk-web (self-checkout kiosk)...');
    // kiosk-web runs via nx serve, not Docker - spawn it in the background
    const kioskProcess = spawn('pnpm', ['nx', 'serve', 'kiosk-web'], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    kioskProcess.unref();
    logSuccess('kiosk-web process started');

    logStep('Waiting for kiosk-web to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3002, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('kiosk-web is ready');
    } else {
      logWarning('kiosk-web may not be fully ready yet');
    }
    startedServices.push('kiosk-web:3002');
  }

  // Start home-portal (platform landing page)
  if (alreadyRunning.has('home-portal')) {
    logSuccess('home-portal already running');
    startedServices.push('home-portal:3003');
  } else {
    logStep('Starting home-portal (platform landing page)...');
    // home-portal runs via nx serve, not Docker - spawn it in the background
    const portalProcess = spawn('pnpm', ['nx', 'serve', 'home-portal'], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    portalProcess.unref();
    logSuccess('home-portal process started');

    logStep('Waiting for home-portal to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3003, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('home-portal is ready');
    } else {
      logWarning('home-portal may not be fully ready yet');
    }
    startedServices.push('home-portal:3003');
  }
}

// Print summary
function printSummary() {
  logHeader('Startup Summary');

  if (failedServices.length > 0) {
    console.log(`${colors.red}Some services failed to start:${colors.nc}`);
    for (const service of failedServices) {
      console.log(`  ${colors.red}✗${colors.nc} ${service}`);
    }
    console.log('');
  }

  console.log(`${colors.green}${colors.bold}Services Running:${colors.nc}`);
  console.log('');

  // Infrastructure
  console.log(`${colors.bold}Infrastructure:${colors.nc}`);
  console.log(`  ${colors.cyan}PostgreSQL${colors.nc}        http://localhost:5432`);
  console.log('                     Connect with: psql -h localhost -U postgres -d postgres');
  console.log('');
  console.log(`  ${colors.cyan}Redis${colors.nc}             http://localhost:6379`);
  console.log('                     Connect with: redis-cli -h localhost');
  console.log('');
  console.log(`  ${colors.cyan}WireMock${colors.nc}          http://localhost:8082`);
  console.log('                     View mappings at: http://localhost:8082/__admin/mappings');
  console.log('');

  // Observability
  console.log(`${colors.bold}Observability:${colors.nc}`);
  console.log(`  ${colors.cyan}Grafana${colors.nc}           http://localhost:3000`);
  console.log('                     Login with admin/admin to view dashboards and explore metrics.');
  console.log('');
  console.log(`  ${colors.cyan}Prometheus${colors.nc}        http://localhost:9090`);
  console.log('');
  console.log(`  ${colors.cyan}Loki${colors.nc}              http://localhost:3100`);
  console.log('');
  console.log(`  ${colors.cyan}Tempo${colors.nc}             http://localhost:3200`);
  console.log('');

  // Backend Services
  console.log(`${colors.bold}Backend Services:${colors.nc}`);
  console.log(`  ${colors.cyan}merchandise-service${colors.nc} http://localhost:8091`);
  console.log(`  ${colors.cyan}price-service${colors.nc}     http://localhost:8092`);
  console.log(`  ${colors.cyan}inventory-service${colors.nc} http://localhost:8093`);
  console.log(`  ${colors.cyan}product-service${colors.nc}   http://localhost:8090`);
  console.log(`  ${colors.cyan}cart-service${colors.nc}      http://localhost:8081`);
  console.log(`  ${colors.cyan}customer-service${colors.nc}  http://localhost:8083`);
  console.log(`  ${colors.cyan}discount-service${colors.nc}  http://localhost:8084`);
  console.log(`  ${colors.cyan}fulfillment-service${colors.nc} http://localhost:8085`);
  console.log(`  ${colors.cyan}audit-service${colors.nc}     http://localhost:8086`);
  console.log(`  ${colors.cyan}checkout-service${colors.nc}  http://localhost:8087`);
  console.log(`  ${colors.cyan}order-service${colors.nc}     http://localhost:8088`);
  console.log(`  ${colors.cyan}user-service${colors.nc}      http://localhost:8089`);
  console.log('');

  // Peripheral Devices
  console.log(`${colors.bold}Peripheral Devices:${colors.nc}`);
  console.log(`  ${colors.cyan}peripheral-emulator${colors.nc}`);
  console.log(`                     WebSocket: ws://localhost:9100/stomp`);
  console.log(`                     Dashboard: http://localhost:9101`);
  console.log('');

  // Frontend Applications
  console.log(`${colors.bold}Frontend Applications:${colors.nc}`);
  console.log(`  ${colors.cyan}home-portal${colors.nc}       http://localhost:3003`);
  console.log('                     Platform landing page (start here!)');
  console.log('');
  console.log(`  ${colors.cyan}ecommerce-web${colors.nc}     http://localhost:3001`);
  console.log('                     Main e-commerce storefront');
  console.log('');
  console.log(`  ${colors.cyan}kiosk-web${colors.nc}         http://localhost:3002`);
  console.log('                     Self-checkout kiosk application');
  console.log('');
  console.log(`  ${colors.cyan}merchant-portal${colors.nc}   http://localhost:3010`);
  console.log('                     Merchant data management portal');
  console.log('');

  // Quick commands
  console.log(`${colors.bold}${colors.yellow}Quick Commands:${colors.nc}`);
  console.log('');
  console.log('  # View logs');
  console.log('  docker compose -f docker/docker-compose.yml logs -f product-service');
  console.log('');
  console.log('  # Stop everything');
  console.log('  docker compose -f docker/docker-compose.yml down');
  console.log('');

  console.log(`${colors.green}${colors.bold}Platform is ready!${colors.nc}`);
  console.log(`  ${colors.bold}Home Portal:${colors.nc}     ${colors.cyan}http://localhost:3003${colors.nc}  ${colors.yellow}← Start here!${colors.nc}`);
  console.log(`  E-commerce:      ${colors.cyan}http://localhost:3001${colors.nc}`);
  console.log(`  Kiosk:           ${colors.cyan}http://localhost:3002${colors.nc}`);
}

// Print banner
function printBanner() {
  console.log(colors.bold);
  console.log('  ____                          ____  _             _   ');
  console.log(' |  _ \\ _____      _____ _ __  / ___|| |_ __ _ _ __| |_ ');
  console.log(' | |_) / _ \\ \\ /\\ / / _ \\ \'__| \\___ \\| __/ _` | \'__| __|');
  console.log(' |  __/ (_) \\ V  V /  __/ |     ___) | || (_| | |  | |_ ');
  console.log(' |_|   \\___/ \\_/\\_/ \\___|_|    |____/ \\__\\__,_|_|   \\__|');
  console.log(colors.nc);
  console.log(`${colors.blue}Starting the Reactive Platform...${colors.nc}`);
}

// Show help
function showHelp() {
  console.log(`
${colors.bold}${colors.cyan}powerstart${colors.nc} - Start, stop, and manage reactive-platform services

${colors.bold}USAGE${colors.nc}
  ./powerstart [command] [options]

${colors.bold}COMMANDS${colors.nc}

  ${colors.cyan}Starting Services:${colors.nc}
    ${colors.bold}(default)${colors.nc}              Start everything (frontend + backends + observability + mocks)
    ${colors.bold}-i, --interactive${colors.nc}     Interactive mode with checkboxes to select service groups
    ${colors.bold}--profile <name>${colors.nc}      Start services using a predefined profile
    ${colors.bold}--frontend${colors.nc}            Start frontend apps only
    ${colors.bold}--backends${colors.nc}            Start backend services + infrastructure
    ${colors.bold}--observability${colors.nc}       Start observability stack (Grafana, Prometheus, etc.)
    ${colors.bold}--mocks${colors.nc}               Start WireMock
    ${colors.bold}--no-frontend${colors.nc}         Start everything except frontend
    ${colors.bold}--no-observability${colors.nc}    Start everything except observability

  ${colors.cyan}Managing Services:${colors.nc}
    ${colors.bold}-s, --stop${colors.nc}            Stop all services
    ${colors.bold}-s <group>${colors.nc}            Stop specific group (frontend, backends, observability, mocks)
    ${colors.bold}--status${colors.nc}              Show status of all services
    ${colors.bold}--health${colors.nc}              Check health of all running services
    ${colors.bold}-l, --logs <service>${colors.nc}  Tail logs for a service (e.g., product-service)
    ${colors.bold}--clean${colors.nc}               Stop all services and prune Docker resources
    ${colors.bold}--clean -v${colors.nc}            Clean and also remove Docker volumes (database data)

  ${colors.cyan}Rebuilding Services:${colors.nc}
    ${colors.bold}-r, --restart${colors.nc}         Interactive mode to select an app to rebuild
    ${colors.bold}-r <app>${colors.nc}              Rebuild and restart specific app

  ${colors.cyan}Other:${colors.nc}
    ${colors.bold}--open${colors.nc}                Open home-portal in browser after startup
    ${colors.bold}-h, --help${colors.nc}            Show this help message

${colors.bold}PROFILES${colors.nc}
  ${colors.cyan}full${colors.nc}       Everything: frontend, backends, observability, mocks
  ${colors.cyan}dev${colors.nc}        Frontend + backends (same as default -i selection)
  ${colors.cyan}backend${colors.nc}    Backend services only (no frontend)
  ${colors.cyan}frontend${colors.nc}   Frontend only (requires backends already running)
  ${colors.cyan}minimal${colors.nc}    Infrastructure only (PostgreSQL, Redis)

${colors.bold}SERVICE GROUPS${colors.nc}
  ${colors.cyan}frontend${colors.nc}       ecommerce-web (:3001), kiosk-web (:3002), home-portal (:3003)
  ${colors.cyan}backends${colors.nc}       product-service, cart-service, customer-service, discount-service,
                 fulfillment-service, audit-service, checkout-service, order-service,
                 user-service, peripheral-emulator + PostgreSQL, Redis
  ${colors.cyan}observability${colors.nc}  Grafana (:3000), Prometheus (:9090), Loki (:3100), Tempo (:3200)
  ${colors.cyan}mocks${colors.nc}          WireMock (:8082)

${colors.bold}EXAMPLES${colors.nc}

  ${colors.dim}# Start everything (default)${colors.nc}
  ./powerstart

  ${colors.dim}# Interactive mode - choose what to start${colors.nc}
  ./powerstart -i

  ${colors.dim}# Quick start with profile${colors.nc}
  ./powerstart --profile dev          ${colors.dim}# Frontend + backends${colors.nc}
  ./powerstart --profile backend      ${colors.dim}# Just backends${colors.nc}
  ./powerstart --profile minimal      ${colors.dim}# Just PostgreSQL + Redis${colors.nc}

  ${colors.dim}# Start specific groups${colors.nc}
  ./powerstart --backends --mocks     ${colors.dim}# Backends + WireMock, no frontend${colors.nc}
  ./powerstart --no-observability     ${colors.dim}# Everything except Grafana stack${colors.nc}

  ${colors.dim}# Check what's running${colors.nc}
  ./powerstart --status
  ./powerstart --health

  ${colors.dim}# View logs${colors.nc}
  ./powerstart -l product-service
  ./powerstart -l grafana

  ${colors.dim}# Rebuild a service after code changes${colors.nc}
  ./powerstart -r product-service
  ./powerstart -r                     ${colors.dim}# Interactive selection${colors.nc}

  ${colors.dim}# Stop services${colors.nc}
  ./powerstart -s                     ${colors.dim}# Stop everything${colors.nc}
  ./powerstart -s frontend            ${colors.dim}# Stop just frontend${colors.nc}

  ${colors.dim}# Clean up${colors.nc}
  ./powerstart --clean                ${colors.dim}# Stop + prune Docker${colors.nc}
  ./powerstart --clean -v             ${colors.dim}# Also remove volumes (reset databases)${colors.nc}

  ${colors.dim}# Start and open browser${colors.nc}
  ./powerstart --open

${colors.bold}COMMON WORKFLOWS${colors.nc}

  ${colors.cyan}Frontend development:${colors.nc}
    ./powerstart --profile backend    ${colors.dim}# Start backends first${colors.nc}
    cd apps/ecommerce-web && pnpm dev ${colors.dim}# Run frontend with HMR${colors.nc}

  ${colors.cyan}Backend development:${colors.nc}
    ./powerstart --profile minimal    ${colors.dim}# Start infra${colors.nc}
    ./gradlew :apps:product-service:bootRun ${colors.dim}# Run service locally${colors.nc}

  ${colors.cyan}Full stack testing:${colors.nc}
    ./powerstart --profile full       ${colors.dim}# Everything including observability${colors.nc}
    open http://localhost:3000        ${colors.dim}# Check Grafana dashboards${colors.nc}

  ${colors.cyan}End of day:${colors.nc}
    ./powerstart -s                   ${colors.dim}# Stop everything${colors.nc}
`);
}

// Create readline interface for interactive mode
function createReadlineInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

// Show interactive menu and get user selection
async function selectAppInteractively() {
  const rl = createReadlineInterface();

  const apps = Object.keys(ALL_APPS);
  const backendApps = apps.filter(a => ALL_APPS[a].type === 'backend');
  const emulatorApps = apps.filter(a => ALL_APPS[a].type === 'emulator');
  const frontendApps = apps.filter(a => ALL_APPS[a].type === 'frontend');

  console.log('');
  console.log(`${colors.bold}Select an app to rebuild and restart:${colors.nc}`);
  console.log('');
  console.log(`${colors.cyan}Backend Services:${colors.nc}`);
  backendApps.forEach((app, i) => {
    console.log(`  ${colors.bold}${i + 1}.${colors.nc} ${app} (port ${ALL_APPS[app].port})`);
  });
  console.log('');
  console.log(`${colors.cyan}Emulators:${colors.nc}`);
  emulatorApps.forEach((app, i) => {
    const num = backendApps.length + i + 1;
    console.log(`  ${colors.bold}${num}.${colors.nc} ${app} (WS: ${ALL_APPS[app].port}, HTTP: ${ALL_APPS[app].httpPort})`);
  });
  console.log('');
  console.log(`${colors.cyan}Frontend Applications:${colors.nc}`);
  frontendApps.forEach((app, i) => {
    const num = backendApps.length + emulatorApps.length + i + 1;
    console.log(`  ${colors.bold}${num}.${colors.nc} ${app} (port ${ALL_APPS[app].port})`);
  });
  console.log('');
  console.log(`  ${colors.bold}0.${colors.nc} Cancel`);
  console.log('');

  return new Promise((resolve) => {
    rl.question(`${colors.yellow}Enter number or app name: ${colors.nc}`, (answer) => {
      rl.close();

      const trimmed = answer.trim();

      // Check if it's a number
      const num = parseInt(trimmed, 10);
      if (!isNaN(num)) {
        if (num === 0) {
          resolve(null);
          return;
        }
        const allApps = [...backendApps, ...emulatorApps, ...frontendApps];
        if (num >= 1 && num <= allApps.length) {
          resolve(allApps[num - 1]);
          return;
        }
      }

      // Check if it's an app name
      if (ALL_APPS[trimmed]) {
        resolve(trimmed);
        return;
      }

      // Partial match
      const match = apps.find(a => a.toLowerCase().includes(trimmed.toLowerCase()));
      if (match) {
        resolve(match);
        return;
      }

      logError(`Unknown app: ${trimmed}`);
      resolve(null);
    });
  });
}

// Interactive service group selection with toggles
async function selectServiceGroupsInteractively() {
  const groups = Object.keys(SERVICE_GROUPS);
  const selected = {};

  // Initialize with defaults
  for (const group of groups) {
    selected[group] = SERVICE_GROUPS[group].default;
  }

  // Clear screen helper
  const clearLines = (count) => {
    for (let i = 0; i < count; i++) {
      process.stdout.write('\x1b[1A'); // Move up
      process.stdout.write('\x1b[2K'); // Clear line
    }
  };

  // Render the menu
  const renderMenu = (cursorPos) => {
    const lines = [];
    lines.push('');
    lines.push(`${colors.bold}Select service groups to start:${colors.nc}`);
    lines.push(`${colors.cyan}Use number keys to toggle, Enter to confirm, q to cancel${colors.nc}`);
    lines.push('');

    groups.forEach((group, i) => {
      const checkbox = selected[group] ? `${colors.green}[✓]${colors.nc}` : '[ ]';
      const highlight = i === cursorPos ? `${colors.bold}${colors.cyan}>` : ' ';
      const name = SERVICE_GROUPS[group].name;
      const desc = SERVICE_GROUPS[group].description;
      lines.push(`${highlight} ${i + 1}. ${checkbox} ${name}${colors.nc}`);
      lines.push(`      ${colors.blue}${desc}${colors.nc}`);
    });

    lines.push('');
    lines.push(`  ${colors.bold}Enter${colors.nc} - Start selected services`);
    lines.push(`  ${colors.bold}q${colors.nc}     - Cancel`);
    lines.push('');

    return lines;
  };

  return new Promise((resolve) => {
    let cursorPos = 0;
    let menuLines = [];

    // Initial render
    menuLines = renderMenu(cursorPos);
    menuLines.forEach(line => console.log(line));

    // Enable raw mode for single keypress detection
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    const cleanup = () => {
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.pause();
      process.stdin.removeAllListeners('data');
    };

    process.stdin.on('data', (key) => {
      // Ctrl+C or q to cancel
      if (key === '\u0003' || key === 'q' || key === 'Q') {
        cleanup();
        console.log('');
        resolve(null);
        return;
      }

      // Enter to confirm
      if (key === '\r' || key === '\n') {
        cleanup();
        console.log('');
        resolve(selected);
        return;
      }

      // Number keys 1-4 to toggle
      const num = parseInt(key, 10);
      if (num >= 1 && num <= groups.length) {
        const group = groups[num - 1];
        selected[group] = !selected[group];

        // Re-render
        clearLines(menuLines.length);
        menuLines = renderMenu(cursorPos);
        menuLines.forEach(line => console.log(line));
      }

      // Arrow keys for navigation (optional visual cursor)
      if (key === '\x1b[A' && cursorPos > 0) { // Up arrow
        cursorPos--;
        clearLines(menuLines.length);
        menuLines = renderMenu(cursorPos);
        menuLines.forEach(line => console.log(line));
      } else if (key === '\x1b[B' && cursorPos < groups.length - 1) { // Down arrow
        cursorPos++;
        clearLines(menuLines.length);
        menuLines = renderMenu(cursorPos);
        menuLines.forEach(line => console.log(line));
      }

      // Space to toggle current selection
      if (key === ' ') {
        const group = groups[cursorPos];
        selected[group] = !selected[group];
        clearLines(menuLines.length);
        menuLines = renderMenu(cursorPos);
        menuLines.forEach(line => console.log(line));
      }
    });
  });
}

// Start services based on selected groups
async function startSelectedServices(selections) {
  const startFrontendApps = selections.frontend;
  const startBackends = selections.backends;
  const startObservability = selections.observability;
  const startMocks = selections.mocks;

  // Build JARs only if backends are selected
  if (startBackends) {
    buildJars();
  }

  // Start infrastructure (postgres, redis) only if backends are selected
  if (startBackends) {
    await startInfrastructureOnly();
  }

  // Start mocks (WireMock) if selected
  if (startMocks) {
    await startMocksOnly();
  }

  // Start observability stack if selected
  if (startObservability) {
    await startObservability_();
  }

  // Start backend services if selected (includes peripheral-emulator)
  if (startBackends) {
    await startPeripheralEmulator();
    await startBackendServices();
  }

  // Start frontend if selected
  if (startFrontendApps) {
    await startFrontend();
  }

  // Print appropriate summary
  printSelectiveSummary(selections);
}

// Start only infrastructure (postgres, redis) without wiremock
async function startInfrastructureOnly() {
  logHeader('Starting Infrastructure Services');

  const toStart = [];
  if (!alreadyRunning.has('PostgreSQL')) toStart.push('postgres');
  if (!alreadyRunning.has('Redis')) toStart.push('redis');

  if (toStart.length === 0) {
    logSuccess('Infrastructure services already running');
    startedServices.push('postgres:5432', 'redis:6379');
    return;
  }

  logStep(`Starting ${toStart.join(', ')}...`);
  exec(`docker compose up -d ${toStart.join(' ')}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Infrastructure containers started');

  logStep('Waiting for infrastructure to be healthy...');

  // Wait for postgres
  if (!alreadyRunning.has('PostgreSQL')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T postgres pg_isready -U postgres`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('PostgreSQL is ready');
      startedServices.push('postgres:5432');
    } else {
      logError('PostgreSQL failed to start');
      failedServices.push('postgres');
    }
  } else {
    startedServices.push('postgres:5432');
  }

  // Wait for redis
  if (!alreadyRunning.has('Redis')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T redis redis-cli ping`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('Redis is ready');
      startedServices.push('redis:6379');
    } else {
      logError('Redis failed to start');
      failedServices.push('redis');
    }
  } else {
    startedServices.push('redis:6379');
  }
}

// Start only mocks (WireMock)
async function startMocksOnly() {
  logHeader('Starting Mocks (WireMock)');

  if (alreadyRunning.has('WireMock')) {
    logSuccess('WireMock already running');
    startedServices.push('wiremock:8082');
    return;
  }

  logStep('Starting WireMock...');
  exec('docker compose up -d wiremock', { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  logStep('Waiting for WireMock to be healthy...');
  let ready = false;
  for (let i = 0; i < 30; i++) {
    if (await isHealthy(8082, '/__admin/mappings')) {
      ready = true;
      break;
    }
    await sleep(1000);
  }
  if (ready) {
    logSuccess('WireMock is ready');
    startedServices.push('wiremock:8082');
  } else {
    logError('WireMock failed to start');
    failedServices.push('wiremock');
  }
}

// Renamed to avoid conflict with existing function
async function startObservability_() {
  logHeader('Starting Observability Stack');

  logStep('Starting Tempo, Loki, Prometheus, and Grafana...');
  exec('docker compose up -d tempo loki prometheus grafana promtail redis-exporter', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Observability containers started');

  logStep('Waiting for observability stack to be healthy...');

  // Wait for grafana
  let ready = false;
  for (let i = 0; i < 60; i++) {
    if (await isHealthy(3000, '/api/health')) {
      ready = true;
      break;
    }
    await sleep(2000);
  }

  if (ready) {
    logSuccess('Grafana is ready');
    startedServices.push('grafana:3000', 'prometheus:9090', 'loki:3100', 'tempo:3200');
  } else {
    logWarning('Grafana may not be fully ready yet');
  }
}

// Print summary for selective startup
function printSelectiveSummary(selections) {
  logHeader('Startup Summary');

  if (failedServices.length > 0) {
    console.log(`${colors.red}Some services failed to start:${colors.nc}`);
    for (const service of failedServices) {
      console.log(`  ${colors.red}✗${colors.nc} ${service}`);
    }
    console.log('');
  }

  console.log(`${colors.green}${colors.bold}Services Running:${colors.nc}`);
  console.log('');

  // Infrastructure (only if backends selected)
  if (selections.backends) {
    console.log(`${colors.bold}Infrastructure:${colors.nc}`);
    console.log(`  ${colors.cyan}PostgreSQL${colors.nc}        http://localhost:5432`);
    console.log(`  ${colors.cyan}Redis${colors.nc}             http://localhost:6379`);
    console.log('');
  }

  // Mocks
  if (selections.mocks) {
    console.log(`${colors.bold}Mocks:${colors.nc}`);
    console.log(`  ${colors.cyan}WireMock${colors.nc}          http://localhost:8082`);
    console.log('                     View mappings at: http://localhost:8082/__admin/mappings');
    console.log('');
  }

  // Observability
  if (selections.observability) {
    console.log(`${colors.bold}Observability:${colors.nc}`);
    console.log(`  ${colors.cyan}Grafana${colors.nc}           http://localhost:3000`);
    console.log('                     Login with admin/admin');
    console.log(`  ${colors.cyan}Prometheus${colors.nc}        http://localhost:9090`);
    console.log(`  ${colors.cyan}Loki${colors.nc}              http://localhost:3100`);
    console.log(`  ${colors.cyan}Tempo${colors.nc}             http://localhost:3200`);
    console.log('');
  }

  // Backend Services
  if (selections.backends) {
    console.log(`${colors.bold}Backend Services:${colors.nc}`);
    console.log(`  ${colors.cyan}product-service${colors.nc}   http://localhost:8090`);
    console.log(`  ${colors.cyan}cart-service${colors.nc}      http://localhost:8081`);
    console.log(`  ${colors.cyan}customer-service${colors.nc}  http://localhost:8083`);
    console.log(`  ${colors.cyan}discount-service${colors.nc}  http://localhost:8084`);
    console.log(`  ${colors.cyan}fulfillment-service${colors.nc} http://localhost:8085`);
    console.log(`  ${colors.cyan}audit-service${colors.nc}     http://localhost:8086`);
    console.log(`  ${colors.cyan}checkout-service${colors.nc}  http://localhost:8087`);
    console.log(`  ${colors.cyan}order-service${colors.nc}     http://localhost:8088`);
    console.log(`  ${colors.cyan}user-service${colors.nc}      http://localhost:8089`);
    console.log('');

    console.log(`${colors.bold}Peripheral Devices:${colors.nc}`);
    console.log(`  ${colors.cyan}peripheral-emulator${colors.nc}`);
    console.log(`                     WebSocket: ws://localhost:9100/stomp`);
    console.log(`                     Dashboard: http://localhost:9101`);
    console.log('');
  }

  // Frontend
  if (selections.frontend) {
    console.log(`${colors.bold}Frontend Applications:${colors.nc}`);
    console.log(`  ${colors.cyan}home-portal${colors.nc}       http://localhost:3003`);
    console.log('                     Platform landing page');
    console.log(`  ${colors.cyan}ecommerce-web${colors.nc}     http://localhost:3001`);
    console.log('                     Main e-commerce storefront');
    console.log(`  ${colors.cyan}kiosk-web${colors.nc}         http://localhost:3002`);
    console.log('                     Self-checkout kiosk');
    console.log('');
  }

  // Quick commands
  console.log(`${colors.bold}${colors.yellow}Quick Commands:${colors.nc}`);
  console.log('');
  console.log('  # View logs');
  console.log('  docker compose -f docker/docker-compose.yml logs -f <service-name>');
  console.log('');
  console.log('  # Stop everything');
  console.log('  docker compose -f docker/docker-compose.yml down');
  console.log('');

  console.log(`${colors.green}${colors.bold}Selected services are ready!${colors.nc}`);

  if (selections.frontend) {
    console.log(`  ${colors.bold}Home Portal:${colors.nc}     ${colors.cyan}http://localhost:3003${colors.nc}  ${colors.yellow}← Start here!${colors.nc}`);
    console.log(`  E-commerce:      ${colors.cyan}http://localhost:3001${colors.nc}`);
    console.log(`  Kiosk:           ${colors.cyan}http://localhost:3002${colors.nc}`);
  }
}

// Kill process on a port
function killProcessOnPort(port) {
  const pid = getPortUser(port);
  if (pid) {
    logStep(`Killing process on port ${port} (PID: ${pid})...`);
    try {
      execSync(`kill -9 ${pid}`, { stdio: 'pipe' });
      logSuccess(`Killed process ${pid}`);
    } catch {
      logWarning(`Could not kill process ${pid}`);
    }
  }
}

// Rebuild and restart a specific backend app
async function rebuildBackendApp(appName) {
  const app = ALL_APPS[appName];
  if (!app || app.type !== 'backend') {
    logError(`${appName} is not a valid backend app`);
    return false;
  }

  logHeader(`Rebuilding ${appName}`);

  // Build the JAR
  logStep(`Building ${appName} bootJar...`);
  try {
    exec(`./gradlew :apps:${appName}:bootJar -q`, { cwd: __dirname });
    logSuccess(`${appName} JAR built successfully`);
  } catch {
    logError(`Failed to build ${appName}`);
    return false;
  }

  // Stop the container
  logStep(`Stopping ${appName} container...`);
  exec(`docker compose stop ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose rm -f ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess(`${appName} container stopped`);

  // Rebuild and start the container (--build ensures new JAR is picked up)
  logStep(`Rebuilding and starting ${appName} container...`);
  exec(`docker compose build ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose up -d ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  // Wait for health
  logStep(`Waiting for ${appName} to be healthy...`);
  if (await waitForHealth(appName, app.port)) {
    logSuccess(`${appName} is ready at http://localhost:${app.port}`);
    return true;
  } else {
    logError(`${appName} failed to become healthy`);
    return false;
  }
}

// Rebuild and restart peripheral emulator
async function rebuildEmulatorApp(appName) {
  const app = ALL_APPS[appName];
  if (!app || app.type !== 'emulator') {
    logError(`${appName} is not a valid emulator app`);
    return false;
  }

  logHeader(`Rebuilding ${appName}`);

  // Stop the container
  logStep(`Stopping ${appName} container...`);
  exec(`docker compose stop ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose rm -f ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess(`${appName} container stopped`);

  // Rebuild and start (Go build happens in Docker)
  logStep(`Rebuilding and starting ${appName} container...`);
  exec(`docker compose build --no-cache ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose up -d ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  // Wait for health
  logStep(`Waiting for ${appName} to be healthy...`);
  if (await waitForHealth(appName, app.httpPort, '/control/state')) {
    logSuccess(`${appName} is ready`);
    logInfo(`  WebSocket: ws://localhost:${app.port}/stomp`);
    logInfo(`  Dashboard: http://localhost:${app.httpPort}`);
    return true;
  } else {
    logError(`${appName} failed to become healthy`);
    return false;
  }
}

// Rebuild and restart a specific frontend app
async function rebuildFrontendApp(appName) {
  const app = ALL_APPS[appName];
  if (!app || app.type !== 'frontend') {
    logError(`${appName} is not a valid frontend app`);
    return false;
  }

  logHeader(`Rebuilding ${appName}`);

  if (app.docker) {
    // Docker-based frontend (ecommerce-web)
    logStep(`Building ${appName}...`);
    try {
      exec(`pnpm nx build ${appName}`, { cwd: __dirname });
      logSuccess(`${appName} built successfully`);
    } catch {
      logError(`Failed to build ${appName}`);
      return false;
    }

    // Stop and restart container
    logStep(`Restarting ${appName} container...`);
    exec(`docker compose stop ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    exec(`docker compose rm -f ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    exec(`docker compose up -d --build ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

    // Wait for health
    logStep(`Waiting for ${appName} to be healthy...`);
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(app.port, '/health') || await isHealthy(app.port, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess(`${appName} is ready at http://localhost:${app.port}`);
      return true;
    } else {
      logWarning(`${appName} may not be fully ready yet`);
      return true;
    }
  } else {
    // Local dev server (kiosk-web, home-portal)

    // Kill existing process on the port
    killProcessOnPort(app.port);
    await sleep(1000);

    // Start the dev server
    logStep(`Starting ${appName} dev server...`);
    const devProcess = spawn('pnpm', ['nx', 'serve', appName], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    devProcess.unref();

    // Wait for health
    logStep(`Waiting for ${appName} to be healthy...`);
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(app.port, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess(`${appName} is ready at http://localhost:${app.port}`);
      return true;
    } else {
      logWarning(`${appName} may not be fully ready yet`);
      return true;
    }
  }
}

// Rebuild and restart a specific app
async function rebuildApp(appName) {
  const app = ALL_APPS[appName];
  if (!app) {
    logError(`Unknown app: ${appName}`);
    logInfo(`Available apps: ${Object.keys(ALL_APPS).join(', ')}`);
    return false;
  }

  if (app.type === 'backend') {
    return await rebuildBackendApp(appName);
  } else if (app.type === 'emulator') {
    return await rebuildEmulatorApp(appName);
  } else {
    return await rebuildFrontendApp(appName);
  }
}

// Helper to get argument value
function getArgValue(args, flag) {
  const index = args.indexOf(flag);
  if (index !== -1 && args[index + 1] && !args[index + 1].startsWith('-')) {
    return args[index + 1];
  }
  return null;
}

// Main
async function main() {
  const args = process.argv.slice(2);
  const shouldOpenBrowser = args.includes('--open');

  // ==================== HELP ====================
  if (args.includes('--help') || args.includes('-h')) {
    showHelp();
    return;
  }

  // ==================== STOP ====================
  if (args.includes('-s') || args.includes('--stop')) {
    const group = getArgValue(args, '-s') || getArgValue(args, '--stop');
    await stopServices(group);
    return;
  }

  // ==================== STATUS ====================
  if (args.includes('--status')) {
    await showStatus();
    return;
  }

  // ==================== HEALTH ====================
  if (args.includes('--health')) {
    const allHealthy = await checkHealth();
    process.exit(allHealthy ? 0 : 1);
  }

  // ==================== LOGS ====================
  if (args.includes('-l') || args.includes('--logs')) {
    const serviceName = getArgValue(args, '-l') || getArgValue(args, '--logs');
    showLogs(serviceName);
    return;
  }

  // ==================== CLEAN ====================
  if (args.includes('--clean')) {
    const removeVolumes = args.includes('-v') || args.includes('--volumes');
    await cleanup(removeVolumes);
    return;
  }

  // ==================== REBUILD/RESTART ====================
  if (args.includes('-r') || args.includes('--restart')) {
    const appArg = getArgValue(args, '-r') || getArgValue(args, '--restart');

    let appName;
    if (appArg) {
      appName = appArg;
    } else {
      printBanner();
      appName = await selectAppInteractively();
    }

    if (!appName) {
      console.log('Cancelled.');
      return;
    }

    const success = await rebuildApp(appName);
    process.exit(success ? 0 : 1);
  }

  // ==================== INTERACTIVE MODE ====================
  if (args.includes('-i') || args.includes('--interactive')) {
    printBanner();
    const selections = await selectServiceGroupsInteractively();

    if (!selections) {
      console.log('Cancelled.');
      return;
    }

    const hasSelection = Object.values(selections).some(v => v);
    if (!hasSelection) {
      logWarning('No service groups selected. Nothing to start.');
      return;
    }

    checkPrerequisites();
    await checkPortConflicts();
    await startSelectedServices(selections);

    if (shouldOpenBrowser) {
      openBrowser();
    }
    return;
  }

  // ==================== PROFILE MODE ====================
  if (args.includes('--profile')) {
    const profileName = getArgValue(args, '--profile');
    if (!profileName || !PROFILES[profileName]) {
      logError(`Unknown profile: ${profileName}`);
      logInfo(`Available profiles: ${Object.keys(PROFILES).join(', ')}`);
      process.exit(1);
    }

    const profile = PROFILES[profileName];
    printBanner();
    logInfo(`Using profile: ${profile.name} (${profile.description})`);

    checkPrerequisites();
    await checkPortConflicts();

    if (profile.infraOnly) {
      await startMinimalInfra();
    } else {
      await startSelectedServices(profile.selections);
    }

    if (shouldOpenBrowser && profile.selections.frontend) {
      openBrowser();
    }
    return;
  }

  // ==================== GROUP FLAGS MODE ====================
  const hasGroupFlags = args.some(a =>
    ['--frontend', '--backends', '--observability', '--mocks',
     '--no-frontend', '--no-backends', '--no-observability', '--no-mocks'].includes(a)
  );

  if (hasGroupFlags) {
    // Start with defaults based on positive/negative flags
    const hasPositiveFlags = args.some(a =>
      ['--frontend', '--backends', '--observability', '--mocks'].includes(a)
    );

    let selections;
    if (hasPositiveFlags) {
      // If any positive flag is specified, start with nothing selected
      selections = { frontend: false, backends: false, observability: false, mocks: false };
      if (args.includes('--frontend')) selections.frontend = true;
      if (args.includes('--backends')) selections.backends = true;
      if (args.includes('--observability')) selections.observability = true;
      if (args.includes('--mocks')) selections.mocks = true;
    } else {
      // If only negative flags, start with everything selected
      selections = { frontend: true, backends: true, observability: true, mocks: true };
    }

    // Apply negative flags
    if (args.includes('--no-frontend')) selections.frontend = false;
    if (args.includes('--no-backends')) selections.backends = false;
    if (args.includes('--no-observability')) selections.observability = false;
    if (args.includes('--no-mocks')) selections.mocks = false;

    const hasSelection = Object.values(selections).some(v => v);
    if (!hasSelection) {
      logWarning('No service groups selected. Nothing to start.');
      return;
    }

    printBanner();
    const selectedGroups = Object.entries(selections)
      .filter(([_, v]) => v)
      .map(([k, _]) => k)
      .join(', ');
    logInfo(`Starting: ${selectedGroups}`);

    checkPrerequisites();
    await checkPortConflicts();
    await startSelectedServices(selections);

    if (shouldOpenBrowser && selections.frontend) {
      openBrowser();
    }
    return;
  }

  // ==================== DEFAULT: START EVERYTHING ====================
  printBanner();
  checkPrerequisites();
  await checkPortConflicts();
  buildJars();
  await startInfrastructure();
  await startObservability();
  await startPeripheralEmulator();
  await startBackendServices();
  await startFrontend();
  printSummary();

  if (shouldOpenBrowser) {
    openBrowser();
  }
}

// Handle Ctrl+C
process.on('SIGINT', () => {
  console.log(`\n${colors.yellow}Interrupted. Services may still be running.${colors.nc}`);
  process.exit(1);
});

main().catch(err => {
  console.error(err);
  process.exit(1);
});
