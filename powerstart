#!/usr/bin/env node

/**
 * powerstart - Start all reactive-platform services
 * A simple way to bring up the entire platform for local development
 *
 * Usage:
 *   ./powerstart           - Start everything (default)
 *   ./powerstart -r        - Interactive mode: select an app to rebuild and restart
 *   ./powerstart -r <app>  - Rebuild and restart a specific app
 *   ./powerstart --help    - Show help
 */

import { execSync, spawn } from 'child_process';
import { existsSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
import * as readline from 'readline';

const __dirname = dirname(fileURLToPath(import.meta.url));
const DOCKER_DIR = join(__dirname, 'docker');

// All available apps that can be rebuilt/restarted
const ALL_APPS = {
  // Backend services (Docker)
  'product-service': { port: 8090, type: 'backend', docker: 'product-service' },
  'cart-service': { port: 8081, type: 'backend', docker: 'cart-service' },
  'customer-service': { port: 8083, type: 'backend', docker: 'customer-service' },
  'discount-service': { port: 8084, type: 'backend', docker: 'discount-service' },
  'fulfillment-service': { port: 8085, type: 'backend', docker: 'fulfillment-service' },
  'audit-service': { port: 8086, type: 'backend', docker: 'audit-service' },
  'checkout-service': { port: 8087, type: 'backend', docker: 'checkout-service' },
  'order-service': { port: 8088, type: 'backend', docker: 'order-service' },
  'user-service': { port: 8089, type: 'backend', docker: 'user-service' },
  // Frontend apps (some Docker, some local)
  'ecommerce-web': { port: 3001, type: 'frontend', docker: 'ecommerce-web' },
  'kiosk-web': { port: 3002, type: 'frontend', docker: null }, // runs locally via nx serve
  'home-portal': { port: 3003, type: 'frontend', docker: null }, // runs locally via nx serve
};

// ANSI colors
const colors = {
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[1;33m',
  blue: '\x1b[0;34m',
  cyan: '\x1b[0;36m',
  bold: '\x1b[1m',
  nc: '\x1b[0m',
};

// Track state
const startedServices = [];
const failedServices = [];
const alreadyRunning = new Set();

// Logging functions
function logHeader(msg) {
  console.log('');
  console.log(`${colors.bold}${colors.blue}${'═'.repeat(62)}${colors.nc}`);
  console.log(`${colors.bold}${colors.blue}  ${msg}${colors.nc}`);
  console.log(`${colors.bold}${colors.blue}${'═'.repeat(62)}${colors.nc}`);
}

function logStep(msg) {
  console.log(`${colors.cyan}▶${colors.nc} ${msg}`);
}

function logSuccess(msg) {
  console.log(`${colors.green}✓${colors.nc} ${msg}`);
}

function logWarning(msg) {
  console.log(`${colors.yellow}⚠${colors.nc} ${msg}`);
}

function logError(msg) {
  console.log(`${colors.red}✗${colors.nc} ${msg}`);
}

function logInfo(msg) {
  console.log(`${colors.blue}ℹ${colors.nc} ${msg}`);
}

// Execute command and return output
function exec(cmd, options = {}) {
  try {
    return execSync(cmd, { encoding: 'utf8', stdio: options.silent ? 'pipe' : 'inherit', ...options });
  } catch (e) {
    if (options.ignoreError) return e.stdout || '';
    throw e;
  }
}

// Execute command silently and return output
function execSilent(cmd) {
  try {
    return execSync(cmd, { encoding: 'utf8', stdio: 'pipe' });
  } catch {
    return '';
  }
}

// Check if a port is in use
function isPortInUse(port) {
  const result = execSilent(`lsof -i :${port} -t`);
  return result.trim().length > 0;
}

// Get PID using a port
function getPortUser(port) {
  return execSilent(`lsof -i :${port} -t`).trim().split('\n')[0];
}

// Get process name by PID
function getProcessName(pid) {
  if (!pid) return 'unknown';
  return execSilent(`ps -p ${pid} -o comm=`).trim() || 'unknown';
}

// Check if a Docker container is using a port
function getContainerOnPort(port) {
  const result = execSilent(`docker ps --filter "publish=${port}" --format "{{.Names}}"`);
  return result.trim().split('\n')[0];
}

// Check if a service health endpoint is responding
async function isHealthy(port, endpoint = '/actuator/health') {
  try {
    const response = await fetch(`http://localhost:${port}${endpoint}`, { signal: AbortSignal.timeout(2000) });
    return response.ok;
  } catch {
    return false;
  }
}

// Wait for a service to be healthy
async function waitForHealth(serviceName, port, endpoint = '/actuator/health', maxRetries = 90) {
  process.stdout.write(`  Waiting for ${serviceName}...`);

  for (let i = 0; i < maxRetries; i++) {
    if (await isHealthy(port, endpoint)) {
      console.log(` ${colors.green}✓${colors.nc}`);
      return true;
    }
    await sleep(2000);
  }

  console.log(` ${colors.red}✗${colors.nc}`);
  return false;
}

// Sleep helper
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Check prerequisites
function checkPrerequisites() {
  logHeader('Checking Prerequisites');

  // Check Docker
  try {
    execSilent('docker --version');
    logSuccess('Docker is available');
  } catch {
    logError('Docker is not installed or not in PATH');
    process.exit(1);
  }

  // Check Docker daemon
  try {
    execSilent('docker info');
    logSuccess('Docker daemon is running');
  } catch {
    logError('Docker daemon is not running');
    process.exit(1);
  }

  // Check docker compose
  try {
    execSilent('docker compose version');
    logSuccess('Docker Compose is available');
  } catch {
    logError('Docker Compose is not available');
    process.exit(1);
  }

  // Check docker-compose.yml exists
  if (!existsSync(join(DOCKER_DIR, 'docker-compose.yml'))) {
    logError(`docker-compose.yml not found in ${DOCKER_DIR}`);
    process.exit(1);
  }
  logSuccess('docker-compose.yml found');
}

// Prompt user for yes/no confirmation
async function promptConfirm(message) {
  const rl = createReadlineInterface();
  return new Promise((resolve) => {
    rl.question(`${colors.yellow}${message} [y/N]: ${colors.nc}`, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

// Check for port conflicts
async function checkPortConflicts() {
  logHeader('Checking for Port Conflicts');

  const ports = [
    { port: 5432, service: 'PostgreSQL' },
    { port: 6379, service: 'Redis' },
    { port: 8090, service: 'product-service' },
    { port: 8081, service: 'cart-service' },
    { port: 8082, service: 'WireMock' },
    { port: 8083, service: 'customer-service' },
    { port: 8084, service: 'discount-service' },
    { port: 8085, service: 'fulfillment-service' },
    { port: 8086, service: 'audit-service' },
    { port: 8087, service: 'checkout-service' },
    { port: 8088, service: 'order-service' },
    { port: 8089, service: 'user-service' },
    { port: 3000, service: 'Grafana' },
    { port: 3001, service: 'ecommerce-web' },
    { port: 3002, service: 'kiosk-web' },
    { port: 3003, service: 'home-portal' },
  ];

  const conflicts = [];

  for (const { port, service } of ports) {
    if (isPortInUse(port)) {
      const container = getContainerOnPort(port);
      if (container) {
        alreadyRunning.add(service);
        logInfo(`${service} already running on port ${port} (container: ${container})`);
      } else {
        const pid = getPortUser(port);
        const processName = getProcessName(pid);
        conflicts.push({ port, service, pid, processName });
      }
    }
  }

  if (conflicts.length > 0) {
    logError('Port conflicts detected!');
    console.log('');
    console.log(`${colors.red}The following ports are in use by other processes:${colors.nc}`);
    for (const { port, service, pid, processName } of conflicts) {
      console.log(`  ${colors.red}✗${colors.nc} Port ${port} (${service}) - used by PID ${pid} (${processName})`);
    }
    console.log('');

    // Ask user if they want to kill the conflicting processes
    const shouldKill = await promptConfirm('Kill these processes and continue?');

    if (shouldKill) {
      console.log('');
      for (const { port, service, pid, processName } of conflicts) {
        logStep(`Killing ${processName} (PID ${pid}) on port ${port} for ${service}...`);
        try {
          execSync(`kill -9 ${pid}`, { stdio: 'pipe' });
          logSuccess(`Killed ${processName} (PID ${pid}) - port ${port} now free for ${service}`);
        } catch {
          logWarning(`Could not kill process ${pid} for ${service}`);
        }
      }
      // Give processes time to release ports
      await sleep(1000);
      console.log('');
      logSuccess('Conflicting processes killed - continuing startup');
    } else {
      console.log('');
      console.log(`${colors.yellow}Startup cancelled. To resolve manually:${colors.nc}`);
      console.log('  1. Stop the conflicting processes');
      console.log('  2. Stop any running E2E stack: docker compose -f docker/docker-compose.e2e.yml down');
      console.log('  3. Stop any running dev stack: docker compose -f docker/docker-compose.yml down');
      console.log('');
      process.exit(1);
    }
  }

  if (alreadyRunning.size > 0) {
    logSuccess('Some services already running - will skip starting them');
  } else {
    logSuccess('All ports are available');
  }
}

// Build JARs
function buildJars() {
  logHeader('Building Application JARs');

  logStep('Building bootJars for all services...');
  logInfo('This may take a few minutes on first run');

  try {
    exec('./gradlew bootJar --parallel -q', { cwd: __dirname });
    logSuccess('All JARs built successfully');
  } catch {
    logError('JAR build failed');
    process.exit(1);
  }
}

// Start infrastructure services
async function startInfrastructure() {
  logHeader('Starting Infrastructure Services');

  const toStart = [];
  if (!alreadyRunning.has('PostgreSQL')) toStart.push('postgres');
  if (!alreadyRunning.has('Redis')) toStart.push('redis');
  if (!alreadyRunning.has('WireMock')) toStart.push('wiremock');

  if (toStart.length === 0) {
    logSuccess('All infrastructure services already running');
    startedServices.push('postgres:5432', 'redis:6379', 'wiremock:8082');
    return;
  }

  logStep(`Starting ${toStart.join(', ')}...`);
  exec(`docker compose up -d ${toStart.join(' ')}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Infrastructure containers started');

  logStep('Waiting for infrastructure to be healthy...');

  // Wait for postgres
  if (!alreadyRunning.has('PostgreSQL')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T postgres pg_isready -U postgres`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('PostgreSQL is ready');
      startedServices.push('postgres:5432');
    } else {
      logError('PostgreSQL failed to start');
      failedServices.push('postgres');
    }
  } else {
    startedServices.push('postgres:5432');
  }

  // Wait for redis
  if (!alreadyRunning.has('Redis')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      try {
        execSilent(`docker compose exec -T redis redis-cli ping`);
        ready = true;
        break;
      } catch {
        await sleep(1000);
      }
    }
    if (ready) {
      logSuccess('Redis is ready');
      startedServices.push('redis:6379');
    } else {
      logError('Redis failed to start');
      failedServices.push('redis');
    }
  } else {
    startedServices.push('redis:6379');
  }

  // Wait for wiremock
  if (!alreadyRunning.has('WireMock')) {
    let ready = false;
    for (let i = 0; i < 30; i++) {
      if (await isHealthy(8082, '/__admin/mappings')) {
        ready = true;
        break;
      }
      await sleep(1000);
    }
    if (ready) {
      logSuccess('WireMock is ready');
      startedServices.push('wiremock:8082');
    } else {
      logError('WireMock failed to start');
      failedServices.push('wiremock');
    }
  } else {
    startedServices.push('wiremock:8082');
  }
}

// Start observability stack
async function startObservability() {
  logHeader('Starting Observability Stack');

  logStep('Starting Tempo, Loki, Prometheus, and Grafana...');
  exec('docker compose up -d tempo loki prometheus grafana promtail redis-exporter', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess('Observability containers started');

  logStep('Waiting for observability stack to be healthy...');

  // Wait for grafana
  let ready = false;
  for (let i = 0; i < 60; i++) {
    if (await isHealthy(3000, '/api/health')) {
      ready = true;
      break;
    }
    await sleep(2000);
  }

  if (ready) {
    logSuccess('Grafana is ready');
    startedServices.push('grafana:3000', 'prometheus:9090', 'loki:3100', 'tempo:3200');
  } else {
    logWarning('Grafana may not be fully ready yet');
  }
}

// Start backend services
async function startBackendServices() {
  logHeader('Starting Backend Services');

  const services = [
    { name: 'product-service', port: 8090 },
    { name: 'customer-service', port: 8083 },
    { name: 'discount-service', port: 8084 },
    { name: 'fulfillment-service', port: 8085 },
    { name: 'audit-service', port: 8086 },
    { name: 'cart-service', port: 8081 },
    { name: 'checkout-service', port: 8087 },
    { name: 'order-service', port: 8088 },
    { name: 'user-service', port: 8089 },
  ];

  const toStart = services.filter(s => !alreadyRunning.has(s.name)).map(s => s.name);

  if (toStart.length === 0) {
    logSuccess('All backend services already running');
    services.forEach(s => startedServices.push(`${s.name}:${s.port}`));
    return;
  }

  logStep(`Starting ${toStart.length} backend services: ${toStart.join(', ')}...`);
  exec(`docker compose up -d ${toStart.join(' ')}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  logStep('Waiting for backend services to be healthy (this may take 1-2 minutes)...');

  for (const { name, port } of services) {
    if (alreadyRunning.has(name)) {
      console.log(`  ${name}... ${colors.green}✓${colors.nc} (already running)`);
      startedServices.push(`${name}:${port}`);
      continue;
    }

    if (await waitForHealth(name, port)) {
      startedServices.push(`${name}:${port}`);
    } else {
      failedServices.push(name);
    }
  }
}

// Start frontend applications
async function startFrontend() {
  logHeader('Starting Frontend Applications');

  // Start ecommerce-web
  if (alreadyRunning.has('ecommerce-web')) {
    logSuccess('ecommerce-web already running');
    startedServices.push('ecommerce-web:3001');
  } else {
    logStep('Starting ecommerce-web...');
    exec('docker compose up -d ecommerce-web', { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    logSuccess('ecommerce-web container started');

    logStep('Waiting for ecommerce-web to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3001, '/health') || await isHealthy(3001, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('ecommerce-web is ready');
    } else {
      logWarning('ecommerce-web may not be fully ready yet');
    }
    startedServices.push('ecommerce-web:3001');
  }

  // Start kiosk-web (self-checkout kiosk application)
  if (alreadyRunning.has('kiosk-web')) {
    logSuccess('kiosk-web already running');
    startedServices.push('kiosk-web:3002');
  } else {
    logStep('Starting kiosk-web (self-checkout kiosk)...');
    // kiosk-web runs via nx serve, not Docker - spawn it in the background
    const kioskProcess = spawn('pnpm', ['nx', 'serve', 'kiosk-web'], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    kioskProcess.unref();
    logSuccess('kiosk-web process started');

    logStep('Waiting for kiosk-web to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3002, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('kiosk-web is ready');
    } else {
      logWarning('kiosk-web may not be fully ready yet');
    }
    startedServices.push('kiosk-web:3002');
  }

  // Start home-portal (platform landing page)
  if (alreadyRunning.has('home-portal')) {
    logSuccess('home-portal already running');
    startedServices.push('home-portal:3003');
  } else {
    logStep('Starting home-portal (platform landing page)...');
    // home-portal runs via nx serve, not Docker - spawn it in the background
    const portalProcess = spawn('pnpm', ['nx', 'serve', 'home-portal'], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    portalProcess.unref();
    logSuccess('home-portal process started');

    logStep('Waiting for home-portal to be healthy...');
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(3003, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess('home-portal is ready');
    } else {
      logWarning('home-portal may not be fully ready yet');
    }
    startedServices.push('home-portal:3003');
  }
}

// Print summary
function printSummary() {
  logHeader('Startup Summary');

  if (failedServices.length > 0) {
    console.log(`${colors.red}Some services failed to start:${colors.nc}`);
    for (const service of failedServices) {
      console.log(`  ${colors.red}✗${colors.nc} ${service}`);
    }
    console.log('');
  }

  console.log(`${colors.green}${colors.bold}Services Running:${colors.nc}`);
  console.log('');

  // Infrastructure
  console.log(`${colors.bold}Infrastructure:${colors.nc}`);
  console.log(`  ${colors.cyan}PostgreSQL${colors.nc}        http://localhost:5432`);
  console.log('                     Connect with: psql -h localhost -U postgres -d postgres');
  console.log('');
  console.log(`  ${colors.cyan}Redis${colors.nc}             http://localhost:6379`);
  console.log('                     Connect with: redis-cli -h localhost');
  console.log('');
  console.log(`  ${colors.cyan}WireMock${colors.nc}          http://localhost:8082`);
  console.log('                     View mappings at: http://localhost:8082/__admin/mappings');
  console.log('');

  // Observability
  console.log(`${colors.bold}Observability:${colors.nc}`);
  console.log(`  ${colors.cyan}Grafana${colors.nc}           http://localhost:3000`);
  console.log('                     Login with admin/admin to view dashboards and explore metrics.');
  console.log('');
  console.log(`  ${colors.cyan}Prometheus${colors.nc}        http://localhost:9090`);
  console.log('');
  console.log(`  ${colors.cyan}Loki${colors.nc}              http://localhost:3100`);
  console.log('');
  console.log(`  ${colors.cyan}Tempo${colors.nc}             http://localhost:3200`);
  console.log('');

  // Backend Services
  console.log(`${colors.bold}Backend Services:${colors.nc}`);
  console.log(`  ${colors.cyan}product-service${colors.nc}   http://localhost:8090`);
  console.log(`  ${colors.cyan}cart-service${colors.nc}      http://localhost:8081`);
  console.log(`  ${colors.cyan}customer-service${colors.nc}  http://localhost:8083`);
  console.log(`  ${colors.cyan}discount-service${colors.nc}  http://localhost:8084`);
  console.log(`  ${colors.cyan}fulfillment-service${colors.nc} http://localhost:8085`);
  console.log(`  ${colors.cyan}audit-service${colors.nc}     http://localhost:8086`);
  console.log(`  ${colors.cyan}checkout-service${colors.nc}  http://localhost:8087`);
  console.log(`  ${colors.cyan}order-service${colors.nc}     http://localhost:8088`);
  console.log(`  ${colors.cyan}user-service${colors.nc}      http://localhost:8089`);
  console.log('');

  // Frontend
  console.log(`${colors.bold}Frontend Applications:${colors.nc}`);
  console.log(`  ${colors.cyan}home-portal${colors.nc}       http://localhost:3003`);
  console.log('                     Platform landing page (start here!)');
  console.log('');
  console.log(`  ${colors.cyan}ecommerce-web${colors.nc}     http://localhost:3001`);
  console.log('                     Main e-commerce storefront');
  console.log('');
  console.log(`  ${colors.cyan}kiosk-web${colors.nc}         http://localhost:3002`);
  console.log('                     Self-checkout kiosk application');
  console.log('');

  // Quick commands
  console.log(`${colors.bold}${colors.yellow}Quick Commands:${colors.nc}`);
  console.log('');
  console.log('  # View logs');
  console.log('  docker compose -f docker/docker-compose.yml logs -f product-service');
  console.log('');
  console.log('  # Stop everything');
  console.log('  docker compose -f docker/docker-compose.yml down');
  console.log('');

  console.log(`${colors.green}${colors.bold}Platform is ready!${colors.nc}`);
  console.log(`  ${colors.bold}Home Portal:${colors.nc}     ${colors.cyan}http://localhost:3003${colors.nc}  ${colors.yellow}← Start here!${colors.nc}`);
  console.log(`  E-commerce:      ${colors.cyan}http://localhost:3001${colors.nc}`);
  console.log(`  Kiosk:           ${colors.cyan}http://localhost:3002${colors.nc}`);
}

// Print banner
function printBanner() {
  console.log(colors.bold);
  console.log('  ____                          ____  _             _   ');
  console.log(' |  _ \\ _____      _____ _ __  / ___|| |_ __ _ _ __| |_ ');
  console.log(' | |_) / _ \\ \\ /\\ / / _ \\ \'__| \\___ \\| __/ _` | \'__| __|');
  console.log(' |  __/ (_) \\ V  V /  __/ |     ___) | || (_| | |  | |_ ');
  console.log(' |_|   \\___/ \\_/\\_/ \\___|_|    |____/ \\__\\__,_|_|   \\__|');
  console.log(colors.nc);
  console.log(`${colors.blue}Starting the Reactive Platform...${colors.nc}`);
}

// Show help
function showHelp() {
  console.log(`
${colors.bold}powerstart${colors.nc} - Start all reactive-platform services

${colors.bold}Usage:${colors.nc}
  ./powerstart              Start everything (default)
  ./powerstart -r           Interactive mode: select an app to rebuild and restart
  ./powerstart -r <app>     Rebuild and restart a specific app
  ./powerstart --help       Show this help

${colors.bold}Available apps:${colors.nc}
  ${colors.cyan}Backend:${colors.nc}
    product-service, cart-service, customer-service, discount-service,
    fulfillment-service, audit-service, checkout-service, order-service, user-service

  ${colors.cyan}Frontend:${colors.nc}
    ecommerce-web, kiosk-web, home-portal

${colors.bold}Examples:${colors.nc}
  ./powerstart -r product-service    Rebuild and restart product-service
  ./powerstart -r kiosk-web          Rebuild and restart kiosk-web
  ./powerstart -r                    Show interactive menu to select app
`);
}

// Create readline interface for interactive mode
function createReadlineInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

// Show interactive menu and get user selection
async function selectAppInteractively() {
  const rl = createReadlineInterface();

  const apps = Object.keys(ALL_APPS);
  const backendApps = apps.filter(a => ALL_APPS[a].type === 'backend');
  const frontendApps = apps.filter(a => ALL_APPS[a].type === 'frontend');

  console.log('');
  console.log(`${colors.bold}Select an app to rebuild and restart:${colors.nc}`);
  console.log('');
  console.log(`${colors.cyan}Backend Services:${colors.nc}`);
  backendApps.forEach((app, i) => {
    console.log(`  ${colors.bold}${i + 1}.${colors.nc} ${app} (port ${ALL_APPS[app].port})`);
  });
  console.log('');
  console.log(`${colors.cyan}Frontend Applications:${colors.nc}`);
  frontendApps.forEach((app, i) => {
    const num = backendApps.length + i + 1;
    console.log(`  ${colors.bold}${num}.${colors.nc} ${app} (port ${ALL_APPS[app].port})`);
  });
  console.log('');
  console.log(`  ${colors.bold}0.${colors.nc} Cancel`);
  console.log('');

  return new Promise((resolve) => {
    rl.question(`${colors.yellow}Enter number or app name: ${colors.nc}`, (answer) => {
      rl.close();

      const trimmed = answer.trim();

      // Check if it's a number
      const num = parseInt(trimmed, 10);
      if (!isNaN(num)) {
        if (num === 0) {
          resolve(null);
          return;
        }
        const allApps = [...backendApps, ...frontendApps];
        if (num >= 1 && num <= allApps.length) {
          resolve(allApps[num - 1]);
          return;
        }
      }

      // Check if it's an app name
      if (ALL_APPS[trimmed]) {
        resolve(trimmed);
        return;
      }

      // Partial match
      const match = apps.find(a => a.toLowerCase().includes(trimmed.toLowerCase()));
      if (match) {
        resolve(match);
        return;
      }

      logError(`Unknown app: ${trimmed}`);
      resolve(null);
    });
  });
}

// Kill process on a port
function killProcessOnPort(port) {
  const pid = getPortUser(port);
  if (pid) {
    logStep(`Killing process on port ${port} (PID: ${pid})...`);
    try {
      execSync(`kill -9 ${pid}`, { stdio: 'pipe' });
      logSuccess(`Killed process ${pid}`);
    } catch {
      logWarning(`Could not kill process ${pid}`);
    }
  }
}

// Rebuild and restart a specific backend app
async function rebuildBackendApp(appName) {
  const app = ALL_APPS[appName];
  if (!app || app.type !== 'backend') {
    logError(`${appName} is not a valid backend app`);
    return false;
  }

  logHeader(`Rebuilding ${appName}`);

  // Build the JAR
  logStep(`Building ${appName} bootJar...`);
  try {
    exec(`./gradlew :apps:${appName}:bootJar -q`, { cwd: __dirname });
    logSuccess(`${appName} JAR built successfully`);
  } catch {
    logError(`Failed to build ${appName}`);
    return false;
  }

  // Stop the container
  logStep(`Stopping ${appName} container...`);
  exec(`docker compose stop ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose rm -f ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  logSuccess(`${appName} container stopped`);

  // Rebuild and start the container (--build ensures new JAR is picked up)
  logStep(`Rebuilding and starting ${appName} container...`);
  exec(`docker compose build ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
  exec(`docker compose up -d ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

  // Wait for health
  logStep(`Waiting for ${appName} to be healthy...`);
  if (await waitForHealth(appName, app.port)) {
    logSuccess(`${appName} is ready at http://localhost:${app.port}`);
    return true;
  } else {
    logError(`${appName} failed to become healthy`);
    return false;
  }
}

// Rebuild and restart a specific frontend app
async function rebuildFrontendApp(appName) {
  const app = ALL_APPS[appName];
  if (!app || app.type !== 'frontend') {
    logError(`${appName} is not a valid frontend app`);
    return false;
  }

  logHeader(`Rebuilding ${appName}`);

  if (app.docker) {
    // Docker-based frontend (ecommerce-web)
    logStep(`Building ${appName}...`);
    try {
      exec(`pnpm nx build ${appName}`, { cwd: __dirname });
      logSuccess(`${appName} built successfully`);
    } catch {
      logError(`Failed to build ${appName}`);
      return false;
    }

    // Stop and restart container
    logStep(`Restarting ${appName} container...`);
    exec(`docker compose stop ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    exec(`docker compose rm -f ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });
    exec(`docker compose up -d --build ${app.docker}`, { cwd: DOCKER_DIR, silent: true, ignoreError: true });

    // Wait for health
    logStep(`Waiting for ${appName} to be healthy...`);
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(app.port, '/health') || await isHealthy(app.port, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess(`${appName} is ready at http://localhost:${app.port}`);
      return true;
    } else {
      logWarning(`${appName} may not be fully ready yet`);
      return true;
    }
  } else {
    // Local dev server (kiosk-web, home-portal)

    // Kill existing process on the port
    killProcessOnPort(app.port);
    await sleep(1000);

    // Start the dev server
    logStep(`Starting ${appName} dev server...`);
    const devProcess = spawn('pnpm', ['nx', 'serve', appName], {
      cwd: __dirname,
      stdio: 'ignore',
      detached: true,
    });
    devProcess.unref();

    // Wait for health
    logStep(`Waiting for ${appName} to be healthy...`);
    let ready = false;
    for (let i = 0; i < 60; i++) {
      if (await isHealthy(app.port, '/')) {
        ready = true;
        break;
      }
      await sleep(2000);
    }

    if (ready) {
      logSuccess(`${appName} is ready at http://localhost:${app.port}`);
      return true;
    } else {
      logWarning(`${appName} may not be fully ready yet`);
      return true;
    }
  }
}

// Rebuild and restart a specific app
async function rebuildApp(appName) {
  const app = ALL_APPS[appName];
  if (!app) {
    logError(`Unknown app: ${appName}`);
    logInfo(`Available apps: ${Object.keys(ALL_APPS).join(', ')}`);
    return false;
  }

  if (app.type === 'backend') {
    return await rebuildBackendApp(appName);
  } else {
    return await rebuildFrontendApp(appName);
  }
}

// Main
async function main() {
  const args = process.argv.slice(2);

  // Handle --help
  if (args.includes('--help') || args.includes('-h')) {
    showHelp();
    return;
  }

  // Handle -r (rebuild/restart mode)
  if (args.includes('-r') || args.includes('--restart')) {
    const rIndex = args.findIndex(a => a === '-r' || a === '--restart');
    const appArg = args[rIndex + 1];

    let appName;
    if (appArg && !appArg.startsWith('-')) {
      // App name provided directly
      appName = appArg;
    } else {
      // Interactive mode
      printBanner();
      appName = await selectAppInteractively();
    }

    if (!appName) {
      console.log('Cancelled.');
      return;
    }

    const success = await rebuildApp(appName);
    process.exit(success ? 0 : 1);
  }

  // Default: start everything
  printBanner();
  checkPrerequisites();
  await checkPortConflicts();
  buildJars();
  await startInfrastructure();
  await startObservability();
  await startBackendServices();
  await startFrontend();
  printSummary();
}

// Handle Ctrl+C
process.on('SIGINT', () => {
  console.log(`\n${colors.yellow}Interrupted. Services may still be running.${colors.nc}`);
  process.exit(1);
});

main().catch(err => {
  console.error(err);
  process.exit(1);
});
