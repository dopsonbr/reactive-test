# 009 Audit Data Service - Event Tracking and Storage

## Overview

This plan introduces an audit-service for capturing, storing, and querying audit events from cart-service and other services. The service provides both a CRUD REST API for direct event submission and a message queue consumer as the primary ingestion mechanism. Audit data is stored in PostgreSQL with optimized indexes for time-series queries.

**Related Plans:**
- **008_CART_SERVICE** - Cart service will publish audit events (can be developed in parallel)

## Goals

1. Create a new audit-service application
2. Implement message queue consumer for audit event ingestion (primary mechanism)
3. Implement CRUD REST API for audit events (secondary/convenience mechanism)
4. Store audit data in PostgreSQL with reactive R2DBC driver
5. Provide query APIs for audit trail retrieval
6. Apply resilience, logging, and security patterns
7. Create shared platform library for audit event publishing

## Architecture

### High-Level Flow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  cart-service   │     │ product-service │     │ other-services  │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                       │
         │ publish               │ publish               │ publish
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Message Queue (Redis Streams)               │
│                         audit-events stream                      │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
                                  │ consume
                                  ▼
                    ┌─────────────────────────┐
                    │     audit-service       │
                    │  ┌──────────────────┐   │
                    │  │ Queue Consumer   │   │    ┌──────────────┐
                    │  └────────┬─────────┘   │    │  REST API    │
                    │           │             │◄───│ (secondary)  │
                    │           ▼             │    └──────────────┘
                    │  ┌──────────────────┐   │
                    │  │ Audit Repository │   │
                    │  └────────┬─────────┘   │
                    └───────────┼─────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │       PostgreSQL        │
                    │   (Relational Database) │
                    └─────────────────────────┘
```

### Module Structure

```
libs/
├── platform/
│   ├── ... (existing)
│   └── platform-audit/              # NEW: Shared audit publishing library
│       ├── AuditEvent.java          # Event record
│       ├── AuditEventPublisher.java # Publisher interface
│       └── RedisStreamPublisher.java # Redis Streams implementation

apps/
├── ... (existing)
└── audit-service/                   # NEW: Audit data service
    ├── consumer/                    # Queue consumer
    ├── controller/                  # REST API
    ├── repository/                  # PostgreSQL R2DBC repository
    ├── domain/                      # Domain models
    └── config/                      # Configuration
```

### Package Naming

| Module | Package |
|--------|---------|
| platform-audit | `org.example.platform.audit` |
| audit-service | `org.example.audit` |

---

## Phase 1: Shared Audit Library (platform-audit)

### 1.1 Audit Event Model

**Location:** `libs/platform/platform-audit/`

**Package:** `org.example.platform.audit`

```java
// AuditEvent.java - shared audit event structure
public record AuditEvent(
    String eventId,          // UUID - generated by publisher
    String eventType,        // e.g., "CART_CREATED", "PRODUCT_ADDED"
    String entityType,       // e.g., "CART", "PRODUCT", "ORDER"
    String entityId,         // e.g., cartId, orderId
    int storeNumber,         // Store context
    String userId,           // User who performed the action
    String sessionId,        // Session context
    String traceId,          // Distributed tracing ID
    Instant timestamp,       // When the event occurred
    Map<String, Object> data // Event-specific payload (JSON serializable)
) {
    public static AuditEvent create(
        String eventType,
        String entityType,
        String entityId,
        int storeNumber,
        String userId,
        String sessionId,
        String traceId,
        Map<String, Object> data
    ) {
        return new AuditEvent(
            UUID.randomUUID().toString(),
            eventType,
            entityType,
            entityId,
            storeNumber,
            userId,
            sessionId,
            traceId,
            Instant.now(),
            data
        );
    }
}

// AuditEventType.java - common event type constants
public final class AuditEventType {
    // Cart events
    public static final String CART_CREATED = "CART_CREATED";
    public static final String CART_DELETED = "CART_DELETED";
    public static final String CART_VIEWED = "CART_VIEWED";
    public static final String PRODUCT_ADDED = "PRODUCT_ADDED";
    public static final String PRODUCT_UPDATED = "PRODUCT_UPDATED";
    public static final String PRODUCT_REMOVED = "PRODUCT_REMOVED";
    public static final String CUSTOMER_SET = "CUSTOMER_SET";
    public static final String CUSTOMER_REMOVED = "CUSTOMER_REMOVED";
    public static final String DISCOUNT_APPLIED = "DISCOUNT_APPLIED";
    public static final String DISCOUNT_REMOVED = "DISCOUNT_REMOVED";
    public static final String FULFILLMENT_ADDED = "FULFILLMENT_ADDED";
    public static final String FULFILLMENT_UPDATED = "FULFILLMENT_UPDATED";
    public static final String FULFILLMENT_REMOVED = "FULFILLMENT_REMOVED";

    // Product events
    public static final String PRODUCT_VIEWED = "PRODUCT_VIEWED";

    // Future: Order events, Payment events, etc.

    private AuditEventType() {}
}

// EntityType.java - entity type constants
public final class EntityType {
    public static final String CART = "CART";
    public static final String PRODUCT = "PRODUCT";
    public static final String ORDER = "ORDER";
    public static final String CUSTOMER = "CUSTOMER";

    private EntityType() {}
}
```

### 1.2 Publisher Interface

```java
// AuditEventPublisher.java - interface for publishing audit events
public interface AuditEventPublisher {
    /**
     * Publishes an audit event asynchronously.
     * Returns immediately; failures are logged but do not propagate.
     */
    Mono<Void> publish(AuditEvent event);

    /**
     * Publishes an audit event and waits for acknowledgment.
     * Use when audit confirmation is required (rare).
     */
    Mono<String> publishAndAwait(AuditEvent event);
}
```

### 1.3 Redis Streams Publisher Implementation

```java
// RedisStreamAuditPublisher.java
@Component
@ConditionalOnProperty(name = "audit.enabled", havingValue = "true")
public class RedisStreamAuditPublisher implements AuditEventPublisher {

    private static final String STREAM_KEY = "audit-events";

    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger;
    private final ReactiveResilience resilience;

    @Override
    public Mono<Void> publish(AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            try {
                String json = objectMapper.writeValueAsString(event);
                Map<String, String> fields = Map.of(
                    "eventId", event.eventId(),
                    "payload", json
                );

                return redisTemplate.opsForStream()
                    .add(StreamRecords.newRecord()
                        .in(STREAM_KEY)
                        .ofMap(fields))
                    .then()
                    .transform(resilience.decorate("audit"))
                    .onErrorResume(e -> {
                        logger.warn(ctx, "Failed to publish audit event", Map.of(
                            "eventType", event.eventType(),
                            "entityId", event.entityId(),
                            "error", e.getMessage()
                        ));
                        return Mono.empty(); // Never fail the main operation
                    });
            } catch (JsonProcessingException e) {
                logger.error(ctx, "Failed to serialize audit event", Map.of(
                    "eventType", event.eventType(),
                    "error", e.getMessage()
                ));
                return Mono.empty();
            }
        });
    }

    @Override
    public Mono<String> publishAndAwait(AuditEvent event) {
        // Similar but returns the record ID for confirmation
    }
}

// NoOpAuditPublisher.java - for when audit is disabled
@Component
@ConditionalOnProperty(name = "audit.enabled", havingValue = "false", matchIfMissing = true)
public class NoOpAuditPublisher implements AuditEventPublisher {

    private final StructuredLogger logger = StructuredLogger.getLogger(NoOpAuditPublisher.class);

    @Override
    public Mono<Void> publish(AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            logger.debug(ctx, "Audit event (disabled)", Map.of(
                "eventType", event.eventType(),
                "entityId", event.entityId()
            ));
            return Mono.empty();
        });
    }

    @Override
    public Mono<String> publishAndAwait(AuditEvent event) {
        return Mono.just("noop-" + event.eventId());
    }
}
```

### 1.4 Auto-Configuration

```java
// AuditAutoConfiguration.java
@Configuration
@EnableConfigurationProperties(AuditProperties.class)
public class AuditAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public ObjectMapper auditObjectMapper() {
        return new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }
}

// AuditProperties.java
@ConfigurationProperties(prefix = "audit")
public record AuditProperties(
    boolean enabled,
    String streamKey,
    Duration publishTimeout
) {
    public AuditProperties() {
        this(false, "audit-events", Duration.ofMillis(500));
    }
}
```

---

## Phase 2: Audit Service Application

### 2.1 Application Setup

**Location:** `apps/audit-service/`

**Port:** 8086

**Dependencies:**
- platform-bom
- platform-logging
- platform-resilience
- platform-error
- platform-webflux
- platform-security
- platform-audit
- spring-boot-starter-webflux
- spring-boot-starter-data-redis-reactive
- spring-boot-starter-data-r2dbc
- r2dbc-postgresql

### 2.2 Domain Models

```java
// AuditRecord.java - persisted audit record (R2DBC entity)
@Table("audit_events")
public class AuditRecord {

    @Id
    private String eventId;

    @Column("event_type")
    private String eventType;

    @Column("entity_type")
    private String entityType;

    @Column("entity_id")
    private String entityId;

    @Column("store_number")
    private int storeNumber;

    @Column("user_id")
    private String userId;

    @Column("session_id")
    private String sessionId;

    @Column("trace_id")
    private String traceId;

    @Column("created_at")
    private Instant createdAt;

    @Column("data")
    private String data;  // JSON string (JSONB in PostgreSQL)

    // Default constructor for R2DBC
    public AuditRecord() {}

    public static AuditRecord fromEvent(AuditEvent event, ObjectMapper mapper) {
        String dataJson;
        try {
            dataJson = mapper.writeValueAsString(event.data());
        } catch (JsonProcessingException e) {
            dataJson = "{}";
        }
        AuditRecord record = new AuditRecord();
        record.eventId = event.eventId();
        record.eventType = event.eventType();
        record.entityType = event.entityType();
        record.entityId = event.entityId();
        record.storeNumber = event.storeNumber();
        record.userId = event.userId();
        record.sessionId = event.sessionId();
        record.traceId = event.traceId();
        record.createdAt = event.timestamp();
        record.data = dataJson;
        return record;
    }

    // Getters and setters omitted for brevity
}
```

### 2.3 PostgreSQL Schema

```sql
-- Main audit events table
-- Optimized with indexes for common query patterns
CREATE TABLE IF NOT EXISTS audit_events (
    event_id VARCHAR(36) PRIMARY KEY,
    event_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(255) NOT NULL,
    store_number INTEGER NOT NULL,
    user_id VARCHAR(50),
    session_id VARCHAR(36),
    trace_id VARCHAR(36),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    data JSONB NOT NULL DEFAULT '{}'
);

-- Index for time-series queries by store and entity type
CREATE INDEX idx_audit_store_entity_time
ON audit_events (store_number, entity_type, created_at DESC);

-- Index for entity lookups (e.g., all events for a specific cart)
CREATE INDEX idx_audit_entity
ON audit_events (entity_type, entity_id, created_at DESC);

-- Index for user activity queries
CREATE INDEX idx_audit_user
ON audit_events (user_id, created_at DESC);

-- Index for event type filtering
CREATE INDEX idx_audit_event_type
ON audit_events (event_type, created_at DESC);

-- GIN index for JSONB data queries (optional, for searching within event data)
CREATE INDEX idx_audit_data_gin
ON audit_events USING GIN (data);

-- Partitioning by month (optional, for large-scale deployments)
-- Can be added later using PostgreSQL declarative partitioning

-- Data retention policy (run periodically via cron or pg_cron)
-- DELETE FROM audit_events WHERE created_at < NOW() - INTERVAL '1 year';
```

---

## Phase 3: Queue Consumer

### 3.1 Redis Streams Consumer

```java
// AuditEventConsumer.java
@Component
public class AuditEventConsumer {

    private static final String STREAM_KEY = "audit-events";
    private static final String CONSUMER_GROUP = "audit-service";
    private static final String CONSUMER_NAME = "audit-consumer-1";

    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final AuditRepository auditRepository;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger;

    @PostConstruct
    public void init() {
        // Create consumer group if not exists
        createConsumerGroup().subscribe();
    }

    @Scheduled(fixedDelay = 100) // Poll every 100ms
    public void consume() {
        readEvents()
            .flatMap(this::processEvent)
            .subscribe();
    }

    private Flux<MapRecord<String, String, String>> readEvents() {
        return redisTemplate.opsForStream()
            .read(Consumer.from(CONSUMER_GROUP, CONSUMER_NAME),
                  StreamReadOptions.empty().count(100).block(Duration.ofMillis(50)),
                  StreamOffset.create(STREAM_KEY, ReadOffset.lastConsumed()))
            .onErrorResume(e -> {
                logger.warn("Failed to read from stream", Map.of("error", e.getMessage()));
                return Flux.empty();
            });
    }

    private Mono<Void> processEvent(MapRecord<String, String, String> record) {
        return Mono.defer(() -> {
            String payload = record.getValue().get("payload");
            AuditEvent event = objectMapper.readValue(payload, AuditEvent.class);

            return auditRepository.save(event)
                .then(acknowledgeRecord(record))
                .doOnSuccess(v -> logger.debug("Processed audit event",
                    Map.of("eventId", event.eventId(), "eventType", event.eventType())))
                .onErrorResume(e -> {
                    logger.error("Failed to process audit event", Map.of(
                        "eventId", record.getValue().get("eventId"),
                        "error", e.getMessage()
                    ));
                    return Mono.empty(); // Don't ack, will be reprocessed
                });
        });
    }

    private Mono<Void> acknowledgeRecord(MapRecord<String, String, String> record) {
        return redisTemplate.opsForStream()
            .acknowledge(STREAM_KEY, CONSUMER_GROUP, record.getId())
            .then();
    }

    private Mono<Void> createConsumerGroup() {
        return redisTemplate.opsForStream()
            .createGroup(STREAM_KEY, CONSUMER_GROUP)
            .onErrorResume(e -> Mono.empty()); // Ignore if already exists
    }
}
```

### 3.2 Batch Processing Configuration

```yaml
# application.yml
audit:
  consumer:
    batch-size: 100
    poll-interval: 100ms
    max-retries: 3
    retry-delay: 1s

  stream:
    key: audit-events
    consumer-group: audit-service
    consumer-name: ${HOSTNAME:audit-consumer-1}
```

---

## Phase 4: REST API

### 4.1 API Endpoints

| Method | Path | Description | Request Body | Response |
|--------|------|-------------|--------------|----------|
| POST | `/audit/events` | Create audit event | `AuditEvent` | `AuditEvent` (201) |
| GET | `/audit/events/{eventId}` | Get event by ID | - | `AuditEvent` (200) |
| GET | `/audit/events` | Query events | Query params | `Page<AuditEvent>` |
| GET | `/audit/entities/{entityType}/{entityId}/events` | Events for entity | Query params | `List<AuditEvent>` |
| GET | `/audit/users/{userId}/events` | Events by user | Query params | `List<AuditEvent>` |
| GET | `/audit/stores/{storeNumber}/events` | Events by store | Query params | `List<AuditEvent>` |

### 4.2 Query Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `startTime` | ISO DateTime | Start of time range (inclusive) |
| `endTime` | ISO DateTime | End of time range (exclusive) |
| `eventType` | String | Filter by event type |
| `entityType` | String | Filter by entity type |
| `limit` | Integer | Max results (default 100, max 1000) |
| `pageToken` | String | Pagination token for next page |

### 4.3 Controller Implementation

```java
// AuditController.java
@RestController
@RequestMapping("/audit")
public class AuditController {

    private final AuditService auditService;
    private final StructuredLogger logger = StructuredLogger.getLogger(AuditController.class);

    // POST /audit/events - Direct event submission (secondary mechanism)
    @PostMapping("/events")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<AuditEvent> createEvent(@RequestBody AuditEvent event) {
        return Mono.deferContextual(ctx -> {
            logger.info(ctx, "Creating audit event via API", Map.of(
                "eventType", event.eventType(),
                "entityId", event.entityId()
            ));
            return auditService.save(event);
        });
    }

    // GET /audit/events/{eventId}
    @GetMapping("/events/{eventId}")
    public Mono<AuditEvent> getEvent(@PathVariable String eventId) {
        return auditService.findById(eventId)
            .switchIfEmpty(Mono.error(new NotFoundException("Audit event not found")));
    }

    // GET /audit/entities/{entityType}/{entityId}/events
    @GetMapping("/entities/{entityType}/{entityId}/events")
    public Flux<AuditEvent> getEventsForEntity(
        @PathVariable String entityType,
        @PathVariable String entityId,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(required = false) String eventType,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByEntity(entityType, entityId,
            new TimeRange(startTime, endTime), eventType, limit);
    }

    // GET /audit/users/{userId}/events
    @GetMapping("/users/{userId}/events")
    public Flux<AuditEvent> getEventsForUser(
        @PathVariable String userId,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByUser(userId, new TimeRange(startTime, endTime), limit);
    }

    // GET /audit/stores/{storeNumber}/events
    @GetMapping("/stores/{storeNumber}/events")
    public Flux<AuditEvent> getEventsForStore(
        @PathVariable int storeNumber,
        @RequestParam String entityType,
        @RequestParam(required = false) Instant startTime,
        @RequestParam(required = false) Instant endTime,
        @RequestParam(required = false) String eventType,
        @RequestParam(defaultValue = "100") int limit
    ) {
        return auditService.findByStoreAndEntityType(storeNumber, entityType,
            new TimeRange(startTime, endTime), eventType, limit);
    }
}
```

---

## Phase 5: Repository Layer

### 5.1 Audit Repository Interface

```java
// AuditRepository.java
public interface AuditRepository {

    Mono<AuditEvent> save(AuditEvent event);

    Mono<AuditEvent> findById(String eventId);

    Flux<AuditEvent> findByEntity(
        String entityType,
        String entityId,
        TimeRange timeRange,
        String eventType,
        int limit
    );

    Flux<AuditEvent> findByUser(
        String userId,
        TimeRange timeRange,
        int limit
    );

    Flux<AuditEvent> findByStoreAndEntityType(
        int storeNumber,
        String entityType,
        TimeRange timeRange,
        String eventType,
        int limit
    );
}
```

### 5.2 R2DBC Repository Implementation

```java
// R2dbcAuditRepository.java
@Repository
public class R2dbcAuditRepository implements AuditRepository {

    private final R2dbcEntityTemplate template;
    private final ObjectMapper objectMapper;
    private final StructuredLogger logger = StructuredLogger.getLogger(R2dbcAuditRepository.class);

    public R2dbcAuditRepository(R2dbcEntityTemplate template, ObjectMapper objectMapper) {
        this.template = template;
        this.objectMapper = objectMapper;
    }

    @Override
    public Mono<AuditEvent> save(AuditEvent event) {
        AuditRecord record = AuditRecord.fromEvent(event, objectMapper);
        return template.insert(record)
            .map(this::toEvent);
    }

    @Override
    public Mono<AuditEvent> findById(String eventId) {
        return template.selectOne(
            Query.query(Criteria.where("event_id").is(eventId)),
            AuditRecord.class
        ).map(this::toEvent);
    }

    @Override
    public Flux<AuditEvent> findByEntity(
        String entityType,
        String entityId,
        TimeRange timeRange,
        String eventType,
        int limit
    ) {
        Criteria criteria = Criteria.where("entity_type").is(entityType)
            .and("entity_id").is(entityId);

        criteria = addTimeRangeCriteria(criteria, timeRange);
        if (eventType != null) {
            criteria = criteria.and("event_type").is(eventType);
        }

        return template.select(
            Query.query(criteria)
                .sort(Sort.by(Sort.Direction.DESC, "created_at"))
                .limit(limit),
            AuditRecord.class
        ).map(this::toEvent);
    }

    @Override
    public Flux<AuditEvent> findByUser(
        String userId,
        TimeRange timeRange,
        int limit
    ) {
        Criteria criteria = Criteria.where("user_id").is(userId);
        criteria = addTimeRangeCriteria(criteria, timeRange);

        return template.select(
            Query.query(criteria)
                .sort(Sort.by(Sort.Direction.DESC, "created_at"))
                .limit(limit),
            AuditRecord.class
        ).map(this::toEvent);
    }

    @Override
    public Flux<AuditEvent> findByStoreAndEntityType(
        int storeNumber,
        String entityType,
        TimeRange timeRange,
        String eventType,
        int limit
    ) {
        Criteria criteria = Criteria.where("store_number").is(storeNumber)
            .and("entity_type").is(entityType);

        criteria = addTimeRangeCriteria(criteria, timeRange);
        if (eventType != null) {
            criteria = criteria.and("event_type").is(eventType);
        }

        return template.select(
            Query.query(criteria)
                .sort(Sort.by(Sort.Direction.DESC, "created_at"))
                .limit(limit),
            AuditRecord.class
        ).map(this::toEvent);
    }

    private Criteria addTimeRangeCriteria(Criteria criteria, TimeRange timeRange) {
        if (timeRange.start() != null) {
            criteria = criteria.and("created_at").greaterThanOrEquals(timeRange.start());
        }
        if (timeRange.end() != null) {
            criteria = criteria.and("created_at").lessThan(timeRange.end());
        }
        return criteria;
    }

    private AuditEvent toEvent(AuditRecord record) {
        Map<String, Object> data;
        try {
            data = objectMapper.readValue(record.getData(),
                new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            data = Map.of();
        }
        return new AuditEvent(
            record.getEventId(),
            record.getEventType(),
            record.getEntityType(),
            record.getEntityId(),
            record.getStoreNumber(),
            record.getUserId(),
            record.getSessionId(),
            record.getTraceId(),
            record.getCreatedAt(),
            data
        );
    }
}
```

---

## Phase 6: Resilience Configuration

### 6.1 Consumer Resilience

```yaml
resilience4j:
  circuitbreaker:
    instances:
      postgres:
        registerHealthIndicator: true
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3

  retry:
    instances:
      postgres:
        maxAttempts: 3
        waitDuration: 500ms
        exponentialBackoffMultiplier: 2
        retryExceptions:
          - io.r2dbc.spi.R2dbcTransientResourceException
          - org.springframework.dao.TransientDataAccessException

  bulkhead:
    instances:
      consumer:
        maxConcurrentCalls: 50
      api:
        maxConcurrentCalls: 100
```

### 6.2 Dead Letter Queue

Events that fail processing after retries are moved to a dead letter stream:

```java
// DeadLetterHandler.java
@Component
public class DeadLetterHandler {

    private static final String DLQ_STREAM = "audit-events-dlq";

    public Mono<Void> handleFailedEvent(AuditEvent event, Throwable error) {
        return redisTemplate.opsForStream()
            .add(StreamRecords.newRecord()
                .in(DLQ_STREAM)
                .ofMap(Map.of(
                    "event", serialize(event),
                    "error", error.getMessage(),
                    "timestamp", Instant.now().toString()
                )))
            .then();
    }
}
```

---

## Phase 7: Security Configuration

### 7.1 OAuth2 Resource Server

```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                // Write access requires audit:write scope
                .pathMatchers(HttpMethod.POST, "/audit/**").hasAuthority("SCOPE_audit:write")
                // Read access requires audit:read scope
                .pathMatchers(HttpMethod.GET, "/audit/**").hasAuthority("SCOPE_audit:read")
                // Health/metrics
                .pathMatchers("/actuator/**").permitAll()
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
            .build();
    }
}
```

### 7.2 Service-to-Service Authentication

Services publishing audit events use client credentials:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          audit-publisher:
            client-id: ${service.name}
            client-secret: ${SERVICE_SECRET}
            scope: audit:write
            authorization-grant-type: client_credentials
```

---

## Phase 8: Logging & Observability

### 8.1 Structured Logging

```java
// Consumer logging
logger.info(ctx, "Processing audit event batch", Map.of(
    "batchSize", records.size(),
    "streamOffset", lastOffset
));

logger.debug(ctx, "Saved audit event", Map.of(
    "eventId", event.eventId(),
    "eventType", event.eventType(),
    "entityType", event.entityType(),
    "entityId", event.entityId(),
    "latencyMs", processingTime
));

logger.warn(ctx, "Failed to process audit event", Map.of(
    "eventId", event.eventId(),
    "error", exception.getMessage(),
    "retryCount", retryCount
));
```

### 8.2 Metrics

| Metric | Type | Description |
|--------|------|-------------|
| `audit_events_received_total` | Counter | Events received from queue |
| `audit_events_processed_total` | Counter | Events successfully processed |
| `audit_events_failed_total` | Counter | Events that failed processing |
| `audit_events_dlq_total` | Counter | Events sent to dead letter queue |
| `audit_processing_latency_seconds` | Histogram | Event processing time |
| `audit_queue_lag` | Gauge | Number of pending events |
| `audit_api_requests_total` | Counter | REST API requests by endpoint |

---

## Phase 9: Testing Strategy

### 9.1 Unit Tests

- Event serialization/deserialization
- Repository query building
- Consumer batch processing logic

### 9.2 Integration Tests

- Redis Streams consumer tests with embedded Redis
- PostgreSQL repository tests with Testcontainers
- Full API tests with WebTestClient

### 9.3 Contract Tests

- Publisher → Consumer contract (event format)
- API contract for query endpoints

### 9.4 Load Tests (k6)

- High-volume event ingestion
- Query performance under load
- Consumer lag scenarios

---

## Implementation Order

### Step 1: Platform Audit Library
1. Create `libs/platform/platform-audit/` directory
2. Implement `AuditEvent` record
3. Implement `AuditEventPublisher` interface
4. Implement `RedisStreamAuditPublisher`
5. Implement `NoOpAuditPublisher`
6. Add auto-configuration
7. Update `settings.gradle.kts`

### Step 2: Audit Service Setup
1. Create `apps/audit-service/` directory
2. Create `build.gradle.kts` with dependencies
3. Create application bootstrap class
4. Configure PostgreSQL R2DBC connection
5. Configure Redis Streams connection

### Step 3: Database Schema
1. Create PostgreSQL schema and indexes
2. Implement `AuditRecord` domain model
3. Implement `R2dbcAuditRepository`

### Step 4: Queue Consumer
1. Implement `AuditEventConsumer`
2. Add batch processing
3. Add retry logic
4. Add dead letter handling

### Step 5: REST API
1. Implement `AuditController`
2. Implement query endpoints
3. Add validation
4. Add pagination

### Step 6: Integration with Cart Service
1. Add `platform-audit` dependency to cart-service
2. Replace `NoOpAuditEventPublisher` with `RedisStreamAuditPublisher`
3. Enable audit publishing via configuration
4. Test end-to-end flow

### Step 7: Security
1. Configure OAuth2 resource server
2. Add scope-based access control
3. Test security

### Step 8: Observability
1. Add metrics
2. Add Grafana dashboards
3. Add alerting rules

### Step 9: Docker & Testing
1. Add PostgreSQL to Docker Compose (if not already present)
2. Update audit-service Docker configuration
3. Write integration tests
4. Write load tests

---

## File Checklist

### New Files to Create

**Platform Audit Library:**
- [ ] `libs/platform/platform-audit/build.gradle.kts`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEvent.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEventType.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/EntityType.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditEventPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/RedisStreamAuditPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/NoOpAuditPublisher.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditAutoConfiguration.java`
- [ ] `libs/platform/platform-audit/src/main/java/org/example/platform/audit/AuditProperties.java`
- [ ] `libs/platform/platform-audit/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`

**Audit Service:**
- [ ] `apps/audit-service/build.gradle.kts`
- [ ] `apps/audit-service/src/main/java/org/example/audit/AuditServiceApplication.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/domain/AuditRecord.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/domain/TimeRange.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/repository/AuditRepository.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/repository/R2dbcAuditRepository.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/consumer/AuditEventConsumer.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/consumer/DeadLetterHandler.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/service/AuditService.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/controller/AuditController.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/SecurityConfig.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/R2dbcConfig.java`
- [ ] `apps/audit-service/src/main/java/org/example/audit/config/RedisStreamConfig.java`
- [ ] `apps/audit-service/src/main/resources/application.yml`
- [ ] `apps/audit-service/src/main/resources/schema.sql`

**Docker:**
- [ ] `docker/postgres/init-audit.sql` (schema initialization)

**Configuration Updates:**
- [ ] `settings.gradle.kts` (add new modules)
- [ ] `docker/docker-compose.yml` (add PostgreSQL if needed, audit-service)

### Files to Modify

- [ ] `apps/cart-service/build.gradle.kts` - add platform-audit dependency
- [ ] `apps/cart-service/src/main/resources/application.yml` - add audit configuration
- [ ] `apps/cart-service/src/main/java/org/example/cart/audit/` - remove local implementations, use platform-audit

---

## Docker Compose Additions

```yaml
# docker-compose.yml additions

# PostgreSQL (may already exist in docker-compose.yml)
postgres:
  image: postgres:16-alpine
  container_name: postgres
  ports:
    - "5432:5432"
  environment:
    POSTGRES_USER: audit
    POSTGRES_PASSWORD: audit
    POSTGRES_DB: audit
  volumes:
    - postgres-data:/var/lib/postgresql/data
    - ./postgres/init-audit.sql:/docker-entrypoint-initdb.d/init-audit.sql
  healthcheck:
    test: ["CMD-SHELL", "pg_isready -U audit -d audit"]
    interval: 10s
    timeout: 5s
    retries: 5

audit-service:
  build:
    context: ..
    dockerfile: apps/audit-service/Dockerfile
  container_name: audit-service
  ports:
    - "8086:8080"
  environment:
    - SPRING_PROFILES_ACTIVE=docker
    - SPRING_R2DBC_URL=r2dbc:postgresql://postgres:5432/audit
    - SPRING_R2DBC_USERNAME=audit
    - SPRING_R2DBC_PASSWORD=audit
    - SPRING_DATA_REDIS_HOST=redis
  depends_on:
    postgres:
      condition: service_healthy
    redis:
      condition: service_started
  labels:
    - "prometheus.scrape=true"
    - "prometheus.port=8080"
    - "prometheus.path=/actuator/prometheus"

volumes:
  postgres-data:
```

---

## Open Questions

1. **Data Retention:** How long should audit data be retained?
   - **Proposed:** 1 year retention, managed via scheduled cleanup job or pg_cron

2. **Event Ordering:** Is strict ordering required within an entity?
   - **Proposed:** Best-effort ordering via timestamp; exact ordering available via eventId

3. **PII Handling:** Should audit events contain PII or reference external stores?
   - **Proposed:** Minimal PII (userId, sessionId); sensitive data references only

4. **Query Access Control:** Should users only see their own audit events?
   - **Proposed:** Scope-based; `audit:read` for service accounts, user-scoped access for end users

5. **Real-time Subscriptions:** Should clients be able to subscribe to audit events?
   - **Proposed:** Future enhancement; add WebSocket/SSE endpoint for real-time streaming

6. **Cross-Service Correlation:** How to correlate events across services?
   - **Proposed:** Use `traceId` from OpenTelemetry for distributed tracing correlation

7. **Table Partitioning:** Should audit_events table be partitioned for large-scale deployments?
   - **Proposed:** Start without partitioning; add monthly partitions via PostgreSQL declarative partitioning if needed
